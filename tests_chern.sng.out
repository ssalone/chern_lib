                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.3.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   Jun 2022
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \
./tests_chern.sng   1>     LIB "chern.lib";
// ** loaded chern.lib (0.8,Nov_2022)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/lrcalc.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/general.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/ring.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/primdec.lib (4.2.1.1,Jul_2021)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/absfact.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/triang.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/random.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/elim.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/matrix.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/nctools.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/polylib.lib (4.2.0.0,Dec_2020)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/inout.lib (4.1.2.0,Feb_2019)
./tests_chern.sng   2> LIB "lrcalc.lib";
// ** redefining LRinstall (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRinstall (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoef (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoef (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRskew (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRskew (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoprod (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoprod (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRschubmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRschubmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining string2list (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining string2int (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/lrcalc.lib (4.1.2.0,Feb_2019)
./tests_chern.sng   3> int REZ=1;
./tests_chern.sng   4> proc fail(string s)
./tests_chern.sng   5. {
./tests_chern.sng   6.   return("Failed in "+s);
./tests_chern.sng   8. }
./tests_chern.sng   9> 
./tests_chern.sng  10. proc check(string s)
./tests_chern.sng  11. {
./tests_chern.sng  12.   if(!REZ)
./tests_chern.sng  14.   {
./tests_chern.sng  16.     fail(s);
./tests_chern.sng  18.     REZ=1;
./tests_chern.sng  20.     return(0);
./tests_chern.sng  22.   }
./tests_chern.sng  24.   else
./tests_chern.sng  26.   {
./tests_chern.sng  28.     return(1);
./tests_chern.sng  30.   }
./tests_chern.sng  32. }
./tests_chern.sng  33> 
./tests_chern.sng  34. proc ensure(int b)
./tests_chern.sng  35. {
./tests_chern.sng  36.   if(b)
./tests_chern.sng  38.   {
./tests_chern.sng  40. //    return(1);
./tests_chern.sng  42.   }
./tests_chern.sng  44.   else
./tests_chern.sng  46.   {
./tests_chern.sng  48.     REZ=0;
./tests_chern.sng  50. //    return(0);
./tests_chern.sng  52.   }
./tests_chern.sng  54. }
./tests_chern.sng  55> 
./tests_chern.sng  56. 
./tests_chern.sng  57. proc test_symm()
./tests_chern.sng  58. {
./tests_chern.sng  59.   string s="symm()";
./tests_chern.sng  61.   // elementary symmetric functions in x, y, z:
./tests_chern.sng  63.   ring r = 0, (x, y, z), dp;
./tests_chern.sng  65.   list l=(x, y, z);
./tests_chern.sng  67.   list rez=symm(l);
./tests_chern.sng  69.   ensure(rez[1] == x+y+z);
./tests_chern.sng  71.   ensure(rez[2] ==  xy+xz+yz);
./tests_chern.sng  73.   ensure(rez[3] ==  xyz);
./tests_chern.sng  75. 
./tests_chern.sng  77.   //now let us compute only the first two symmetric polynomials in a(1), ... , a(10)
./tests_chern.sng  79.   ring q= 0,(a(1..10)), dp;
./tests_chern.sng  81.   list l=a(1..10);
./tests_chern.sng  83.   list rez=symm(l, 2);
./tests_chern.sng  85. 
./tests_chern.sng  87.   ensure(rez[1]== a(1)+a(2)+a(3)+a(4)+a(5)+a(6)+a(7)+a(8)+a(9)+a(10));
./tests_chern.sng  89.   ensure(rez[2]== a(1)*a(2)+a(1)*a(3)+a(2)*a(3)+a(1)*a(4)+a(2)*a(4)+a(3)*a(4)+a(1)*a(5)+a(2)*a(5)+a(3)*a(5)+a(4)*a(5)+a(1)*a(6)+a(2)*a(6)+a(3)*a(6)+a(4)*a(6)+a(5)*a(6)+a(1)*a(7)+a(2)*a(7)+a(3)*a(7)+a(4)*a(7)+a(5)*a(7)+a(6)*a(7)+a(1)*a(8)+a(2)*a(8)+a(3)*a(8)+a(4)*a(8)+a(5)*a(8)+a(6)*a(8)+a(7)*a(8)+a(1)*a(9)+a(2)*a(9)+a(3)*a(9)+a(4)*a(9)+a(5)*a(9)+a(6)*a(9)+a(7)*a(9)+a(8)*a(9)+a(1)*a(10)+a(2)*a(10)+a(3)*a(10)+a(4)*a(10)+a(5)*a(10)+a(6)*a(10)+a(7)*a(10)+a(8)*a(10)+a(9)*a(10));
./tests_chern.sng  91.   return(check(s));
./tests_chern.sng  93. 
./tests_chern.sng  95. }
./tests_chern.sng  96> 
./tests_chern.sng  97. proc test_symNsym()
./tests_chern.sng  98. {
./tests_chern.sng  99.   string s="symNsym()";
./tests_chern.sng 101.   ring r=0, (x,y,z, c(1..3)), dp;
./tests_chern.sng 103.   list l=c(1..3);
./tests_chern.sng 105.   // The symmetric part of f = 3x2 + 3y2 + 3z2 + 7xyz + y
./tests_chern.sng 107.   // in terms of the elemenatary symmetric functions c(1), c(2), c(3)
./tests_chern.sng 109.   // and the remainder
./tests_chern.sng 111.   poly f = 3x2 + 3y2 + 3z2 + 7xyz + y;
./tests_chern.sng 113.   list rez= symNsym(f, l);
./tests_chern.sng 115.   ensure(rez[1]== 3*c(1)^2-6*c(2)+7*c(3));
./tests_chern.sng 117.   ensure(rez[2]==  y);
./tests_chern.sng 119.   // Take a symmetrix polynomial in variables x and z
./tests_chern.sng 121.   f=x2+xz+z2;
./tests_chern.sng 123.   // Express it in terms of the elementary the symmetric functions
./tests_chern.sng 125.   rez= symNsym(f, l);
./tests_chern.sng 127.   ensure(rez[1]==c(1)^2-c(2));
./tests_chern.sng 129.   ensure(rez[2]==0);
./tests_chern.sng 131.   return(check(s));
./tests_chern.sng 133. }
./tests_chern.sng 134> 
./tests_chern.sng 135. proc test_symNsymBugFix()
./tests_chern.sng 136. {
./tests_chern.sng 137.   string s="symNsymBugFix()";
./tests_chern.sng 139.   ring R0=0,(z,y,x,s1,s2,s3),lp;
./tests_chern.sng 141.   list ls=s1,s2,s3;
./tests_chern.sng 143.   poly q0=(x^2+2)*(y^2+2)*(z^2+2)-x*(y^2+2)*(z^2+2)-(x^2+2)*y*(z^2+2)-(z^2+2)*(y^2+2)*z;
./tests_chern.sng 145. 
./tests_chern.sng 147.   list result = symNsym(q0,ls);   // this gives the following error
./tests_chern.sng 149.   ensure(result[1] == 2*s1^2*s3-s1*s2^2+s3^2+8);
./tests_chern.sng 151.   ensure(result[2] == z^3*x^2-2*z^3+z^2*y^3+2*z^2*y^2-2*z^2*y+z^2*x^3+2*z^2*x^2-2*z^2*x+4*z^2+z*y^2*x^2-2*z*y^2-4*z+y^3*x^2+y^2*x^3+2*y^2*x^2-2*y^2*x+4*y^2-2*y*x^2-4*y+4*x^2-4*x);
./tests_chern.sng 153.   return(check(s));
./tests_chern.sng 155. }
./tests_chern.sng 156> 
./tests_chern.sng 157. proc test_symNsymRandomData()
./tests_chern.sng 158. {
./tests_chern.sng 159.   string s="symNsymRandomData()";
./tests_chern.sng 161.   ring R0=0,(z,y,x,s1,s2,s3),lp;
./tests_chern.sng 163.   list ls=s1,s2,s3;
./tests_chern.sng 165. 
./tests_chern.sng 167.   int i;
./tests_chern.sng 169.   poly randomPoly;
./tests_chern.sng 171.   ideal I = x,y,z;
./tests_chern.sng 173.   list S= symm(list(x, y, z));
./tests_chern.sng 175.   I=I,I^2, I^3, I^4;
./tests_chern.sng 177.   list result;
./tests_chern.sng 179.   for(i=1;i<=100;i++)
./tests_chern.sng 181.   {
./tests_chern.sng 183.     randomPoly = (I*random(40, 34, 1))[1,1];
./tests_chern.sng 185.     result = symNsym(randomPoly, ls);
./tests_chern.sng 187. 
./tests_chern.sng 189.     ensure(subst(result[1], s1, S[1], s2, S[2], s3, S[3])+result[2] == randomPoly);
./tests_chern.sng 191.     ensure(symNsym(subst(result[1], s1, S[1], s2, S[2], s3, S[3]), ls)[1] == result[1]);
./tests_chern.sng 193.   }
./tests_chern.sng 195.   return(check(s));
./tests_chern.sng 197. }
./tests_chern.sng 198> 
./tests_chern.sng 199. 
./tests_chern.sng 200. proc test_CompleteHomog()
./tests_chern.sng 201. {
./tests_chern.sng 202.   string s= "CompleteHomog()";
./tests_chern.sng 204.   ring r = 0, (x(1..3)), dp;
./tests_chern.sng 206.   list l=x(1..3);
./tests_chern.sng 208.   //Complete homogeneous symmetric polynomials up to degree 3 in variables x(1), x(2), x(3)
./tests_chern.sng 210.   list rez= CompleteHomog(3, l) ;
./tests_chern.sng 212.   ensure(rez[1]==1);
./tests_chern.sng 214.   ensure(rez[2]==x(1));
./tests_chern.sng 216.   ensure(rez[3]== x(1)^2-x(2));
./tests_chern.sng 218.   ensure(rez[4]== x(1)^3-2*x(1)*x(2)+x(3));
./tests_chern.sng 220.   return(check(s));
./tests_chern.sng 222. }
./tests_chern.sng 223> 
./tests_chern.sng 224. proc test_segre()
./tests_chern.sng 225. {
./tests_chern.sng 226.   string s="segre()";
./tests_chern.sng 228.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 230.   list l=c(1..3);
./tests_chern.sng 232.   //Segre classes up to degree 5 in Chern classes c(1), c(2), c(3)
./tests_chern.sng 234.   list rez= segre(l, 5);
./tests_chern.sng 236.   ensure( rez[1] == -c(1));
./tests_chern.sng 238.   ensure( rez[2] == c(1)^2-c(2));
./tests_chern.sng 240.   ensure( rez[3] == -c(1)^3+2*c(1)*c(2)-c(3));
./tests_chern.sng 242.   ensure( rez[4] ==  c(1)^4-3*c(1)^2*c(2)+c(2)^2+2*c(1)*c(3));
./tests_chern.sng 244.   ensure(rez[5] == -c(1)^5+4*c(1)^3*c(2)-3*c(1)*c(2)^2-3*c(1)^2*c(3)+2*c(2)*c(3));
./tests_chern.sng 246.   return(check(s));
./tests_chern.sng 248. 
./tests_chern.sng 250. }
./tests_chern.sng 251> 
./tests_chern.sng 252. 
./tests_chern.sng 253. proc test_chern()
./tests_chern.sng 254. {
./tests_chern.sng 255.   string s="chern()";
./tests_chern.sng 257.   ring r = 0, (s(1..3)), dp;
./tests_chern.sng 259.   list l=s(1..3);
./tests_chern.sng 261.   // Chern classes in Segre classes s(1), s(2), s(3)
./tests_chern.sng 263.   list rez= chern(l);
./tests_chern.sng 265.   ensure(rez[1]==   -s(1));
./tests_chern.sng 267.   ensure(rez[2]==   s(1)^2-s(2));
./tests_chern.sng 269.   ensure(rez[3]==  -s(1)^3+2*s(1)*s(2)-s(3));
./tests_chern.sng 271.   // This procedure is inverse to segre(...). Indeed:
./tests_chern.sng 273.   rez=segre(chern(l), 3) ;
./tests_chern.sng 275.   ensure(rez[1]==  s(1));
./tests_chern.sng 277.   ensure(rez[2]==   s(2));
./tests_chern.sng 279.   ensure(rez[3]==   s(3));
./tests_chern.sng 281.   return(check(s));
./tests_chern.sng 283. 
./tests_chern.sng 285. }
./tests_chern.sng 286> proc test_chNum()
./tests_chern.sng 287. {
./tests_chern.sng 288.   string s="chNum()";
./tests_chern.sng 290.   ring r = 0, (c(1..2)), dp;
./tests_chern.sng 292.   list l=c(1..2);
./tests_chern.sng 294.   // Let c(1) be a variable of degree 1, let c(2) be a variable of degree 2.
./tests_chern.sng 296.   // The monomials in c(1) and c(2) of weighted degree 5 are:
./tests_chern.sng 298.   list rez= chNum( 5, l ) ;
./tests_chern.sng 300.   ensure(rez[1]==   c(1)^5);
./tests_chern.sng 302.   ensure(rez[2]==   c(1)^3*c(2));
./tests_chern.sng 304.   ensure(rez[3]==   c(1)*c(2)^2);
./tests_chern.sng 306.   return(check(s));
./tests_chern.sng 308. }
./tests_chern.sng 309> 
./tests_chern.sng 310. proc test_chNumbers()
./tests_chern.sng 311. {
./tests_chern.sng 312.   string s= "chNumbers()";
./tests_chern.sng 314.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 316.   list l=c(1..3);
./tests_chern.sng 318.   // The Chern numbers of a vector bundle with Chern classes c(1), c(2), c(3)
./tests_chern.sng 320.   // on a 3-fold:
./tests_chern.sng 322.   list rez= chNumbers( 3, l );
./tests_chern.sng 324.   ensure(rez[1] ==  c(1)^3);
./tests_chern.sng 326.   ensure(rez[2]==    c(1)*c(2));
./tests_chern.sng 328.   ensure(rez[3]==   c(3));
./tests_chern.sng 330.   // If the highest Chern class is zero, the Chern numbers are:
./tests_chern.sng 332.   l=c(1..2);
./tests_chern.sng 334.   rez= chNumbers( 3, l );
./tests_chern.sng 336.   ensure(rez[1]==   c(1)^3);
./tests_chern.sng 338.   ensure(rez[2]== c(1)*c(2));
./tests_chern.sng 340.   ensure(rez[3]==   0);
./tests_chern.sng 342.   return(check(s));
./tests_chern.sng 344. }
./tests_chern.sng 345> 
./tests_chern.sng 346. proc test_sum_of_powers()
./tests_chern.sng 347. {
./tests_chern.sng 348.   string s="sum_of_powers()";
./tests_chern.sng 350.   ring r = 0, (x, y, z), dp;
./tests_chern.sng 352.   list l=x, y, z;
./tests_chern.sng 354.   //sum of 7-th powers of x, y, z
./tests_chern.sng 356.   poly rez= sum_of_powers(7, l);
./tests_chern.sng 358.   ensure( rez==x7+y7+z7 );
./tests_chern.sng 360.   return(check(s));
./tests_chern.sng 362. 
./tests_chern.sng 364. }
./tests_chern.sng 365> 
./tests_chern.sng 366. proc test_powSumSym()
./tests_chern.sng 367. {
./tests_chern.sng 368.   string  s= "powSumSym()";
./tests_chern.sng 370. 
./tests_chern.sng 372.   // the expressions of the first 3 sums of powers of 3 variables a(1), a(2), a(3)
./tests_chern.sng 374.   // in terms of the elementary symmetric polynomials c(1), c(2), c(3):
./tests_chern.sng 376.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 378.   list l=(c(1..3));
./tests_chern.sng 380.   list rez=powSumSym(l);
./tests_chern.sng 382.   ensure(rez[1]==  c(1) );
./tests_chern.sng 384.   ensure(rez[2]==  c(1)^2-2*c(2)) ;
./tests_chern.sng 386.   ensure(rez[3]==   c(1)^3-3*c(1)*c(2)+3*c(3));
./tests_chern.sng 388.   
./tests_chern.sng 390.   // The first 5 sums in the same situation
./tests_chern.sng 392.   rez= powSumSym(l, 5);
./tests_chern.sng 394.   ensure(rez[1]==   c(1));
./tests_chern.sng 396.   ensure(rez[2]==  c(1)^2-2*c(2));
./tests_chern.sng 398.   ensure(rez[3]==   c(1)^3-3*c(1)*c(2)+3*c(3));
./tests_chern.sng 400.   ensure(rez[4]==   c(1)^4-4*c(1)^2*c(2)+2*c(2)^2+4*c(1)*c(3) );
./tests_chern.sng 402.   ensure(rez[5]==   c(1)^5-5*c(1)^3*c(2)+5*c(1)*c(2)^2+5*c(1)^2*c(3)-5*c(2)*c(3));
./tests_chern.sng 404.   return(check(s));
./tests_chern.sng 406. }
./tests_chern.sng 407> 
./tests_chern.sng 408. proc test_chAll()
./tests_chern.sng 409. {
./tests_chern.sng 410.   string s="chAll()";
./tests_chern.sng 412.   // Chern character (terms of degree 1, 2, 3)
./tests_chern.sng 414.   // corresponding to the Chern classes c(1), c(2), c(3):
./tests_chern.sng 416.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 418.   list l=(c(1..3));
./tests_chern.sng 420.   list rez= chAll(l);
./tests_chern.sng 422.   ensure(rez[1]==   c(1));
./tests_chern.sng 424.   ensure(rez[2]==   1/2*c(1)^2-c(2));
./tests_chern.sng 426.   ensure(rez[3]==   1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 428.   // terms up to degree 5 in the same situation
./tests_chern.sng 430.   rez=chAll(l, 5);
./tests_chern.sng 432.   ensure(rez[1]==   c(1));
./tests_chern.sng 434.   ensure(rez[2]==   1/2*c(1)^2-c(2));
./tests_chern.sng 436.   ensure(rez[3]==   1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 438.   ensure(rez[4]==   1/24*c(1)^4-1/6*c(1)^2*c(2)+1/12*c(2)^2+1/6*c(1)*c(3));
./tests_chern.sng 440.   ensure(rez[5]==   1/120*c(1)^5-1/24*c(1)^3*c(2)+1/24*c(1)*c(2)^2+1/24*c(1)^2*c(3)-1/24*c(2)*c(3));
./tests_chern.sng 442.   return(check(s));
./tests_chern.sng 444. 
./tests_chern.sng 446. }
./tests_chern.sng 447> 
./tests_chern.sng 448. proc test_chAllInv()
./tests_chern.sng 449. {
./tests_chern.sng 450.   string s="chAllInv()";
./tests_chern.sng 452.   // first 3 Chern classes in terms of the first 3 terms
./tests_chern.sng 454.   // of the Chern character Chern  ch(1), ch(2), ch(3):
./tests_chern.sng 456.   ring r = 0, (ch(1..3)), dp;
./tests_chern.sng 458.   list l=(ch(1..3));
./tests_chern.sng 460.   list rez= chAllInv(l);
./tests_chern.sng 462.   ensure(rez[1]==   ch(1));
./tests_chern.sng 464.   ensure(rez[2]==   1/2*ch(1)^2-ch(2));
./tests_chern.sng 466.   ensure(rez[3]==   1/6*ch(1)^3-ch(1)*ch(2)+2*ch(3));
./tests_chern.sng 468.   // let's see that chAllInv() is inverse to chAll()
./tests_chern.sng 470.   rez=chAll( chAllInv(l) ) ;
./tests_chern.sng 472.   ensure(rez[1]==   ch(1));
./tests_chern.sng 474.   ensure(rez[2]==   ch(2));
./tests_chern.sng 476.   ensure(rez[3]==   ch(3));
./tests_chern.sng 478.   return(check(s));
./tests_chern.sng 480. }
./tests_chern.sng 481> 
./tests_chern.sng 482. proc test_chHE()
./tests_chern.sng 483. {
./tests_chern.sng 484.   string s="chHE()"; 
./tests_chern.sng 486.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 488.   list l=c(1..3);
./tests_chern.sng 490.   //the third degree term of the Chern character
./tests_chern.sng 492.   poly rez= chHE(l);
./tests_chern.sng 494.   ensure(rez== 1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 496.   return(check(s));
./tests_chern.sng 498. }
./tests_chern.sng 499> 
./tests_chern.sng 500. 
./tests_chern.sng 501. proc test_ChernRootsSum()
./tests_chern.sng 502. {
./tests_chern.sng 503.   string s="ChernRootsSum()";
./tests_chern.sng 505.   ring r = 0, (a(1..3), b(1..2)), dp;
./tests_chern.sng 507.   // assume a(1), a(2), a(3) are the Chern roots of a vector bundle E
./tests_chern.sng 509.   // assume b(1), b(2) are the Chern roots of a vector bundle F
./tests_chern.sng 511.   list l=a(1..3);
./tests_chern.sng 513.   list L=b(1..2);
./tests_chern.sng 515.   // the Chern roots of their direct sum is
./tests_chern.sng 517.   list rez= ChernRootsSum(l, L);
./tests_chern.sng 519.   ensure(rez[1]== a(1));
./tests_chern.sng 521.   ensure(rez[2]== a(2));
./tests_chern.sng 523.   ensure(rez[3]== a(3));
./tests_chern.sng 525.   ensure(rez[4]== b(1));
./tests_chern.sng 527.   ensure(rez[5]== b(2));
./tests_chern.sng 529.   return(check(s));
./tests_chern.sng 531. }
./tests_chern.sng 532> 
./tests_chern.sng 533. proc test_chSum()
./tests_chern.sng 534. {
./tests_chern.sng 535.   string s="chSum()";
./tests_chern.sng 537.   ring r = 0, (c(1..3), C(1..2)), dp;
./tests_chern.sng 539.   // Let E be a vector bundle with Chern classes c(1), c(2), c(3).
./tests_chern.sng 541.   // Let F be a vector bundle with Chern classes C(1), C(2).
./tests_chern.sng 543.   list l=c(1..3);
./tests_chern.sng 545.   list L=C(1..2);
./tests_chern.sng 547.   // Then the Chern classes of their direct sum are
./tests_chern.sng 549.   list rez= chSum(l, L);
./tests_chern.sng 551.   ensure(rez[1]== c(1)+C(1));
./tests_chern.sng 553.   ensure(rez[2]== c(1)*C(1)+c(2)+C(2));
./tests_chern.sng 555.   ensure(rez[3]== c(2)*C(1)+c(1)*C(2)+c(3));
./tests_chern.sng 557.   ensure(rez[4]== c(3)*C(1)+c(2)*C(2));
./tests_chern.sng 559.   ensure(rez[5]== c(3)*C(2));
./tests_chern.sng 561.   return(check(s));
./tests_chern.sng 563. 
./tests_chern.sng 565. }
./tests_chern.sng 566> 
./tests_chern.sng 567. proc test_ChernRootsDual()
./tests_chern.sng 568. {
./tests_chern.sng 569.   string s="ChernRootsDual()";
./tests_chern.sng 571.   ring r = 0, (a(1..3)), dp;
./tests_chern.sng 573.   // assume a(1), a(2), a(3) are the Chern roots of a vector bundle
./tests_chern.sng 575.   list l=a(1..3);
./tests_chern.sng 577.   // the Chern roots of the dual vector bundle
./tests_chern.sng 579.   list rez=ChernRootsDual(l);
./tests_chern.sng 581.   ensure(rez[1]==   -a(1));
./tests_chern.sng 583.   ensure(rez[2]==  -a(2));
./tests_chern.sng 585.   ensure(rez[3]==  -a(3));
./tests_chern.sng 587.   return(check(s));
./tests_chern.sng 589. }
./tests_chern.sng 590> 
./tests_chern.sng 591. proc test_chDual()
./tests_chern.sng 592. {
./tests_chern.sng 593.   string s="chDual()";
./tests_chern.sng 595.   // Chern classes of a vector bundle that is dual to a vector bundle
./tests_chern.sng 597.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 599.   ring r=0, (c(1..3)), dp;
./tests_chern.sng 601.   list l=c(1..3);
./tests_chern.sng 603.   list rez=chDual(l);
./tests_chern.sng 605.   ensure(rez[1]== -c(1));
./tests_chern.sng 607.   ensure(rez[2]==   c(2));
./tests_chern.sng 609.   ensure(rez[3]==  -c(3));
./tests_chern.sng 611. 
./tests_chern.sng 613.   return(check(s));
./tests_chern.sng 615. }
./tests_chern.sng 616> 
./tests_chern.sng 617. proc test_ChernRootsProd()
./tests_chern.sng 618. {
./tests_chern.sng 619.   string s="ChernRootsProd()";
./tests_chern.sng 621.   ring r=0, (a(1..2), b(1..3)), dp;
./tests_chern.sng 623.   list l=a(1..2);
./tests_chern.sng 625.   list L=b(1..3);
./tests_chern.sng 627.   // Chern roots of the tensor product of a vector bundle with Chern roots a(1), a(2)
./tests_chern.sng 629.   // and a vector bundle with Chern roots b(1), b(2), b(3)
./tests_chern.sng 631.   list rez= ChernRootsProd(l, L);
./tests_chern.sng 633.   ensure(rez[1]==   a(1)+b(1));
./tests_chern.sng 635.   ensure(rez[2]==    a(1)+b(2));
./tests_chern.sng 637.   ensure(rez[3]==   a(1)+b(3));
./tests_chern.sng 639.   ensure(rez[4]==   a(2)+b(1));
./tests_chern.sng 641.   ensure(rez[5]==  a(2)+b(2));
./tests_chern.sng 643.   ensure(rez[6]==   a(2)+b(3));
./tests_chern.sng 645.   return(check(s));
./tests_chern.sng 647. }
./tests_chern.sng 648> 
./tests_chern.sng 649. proc test_chProd()
./tests_chern.sng 650. {
./tests_chern.sng 651.   string s="chProd";
./tests_chern.sng 653.   ring H = 0, ( r, R, c(1..3), C(1..2) ), dp;
./tests_chern.sng 655.   list l=c(1..3);
./tests_chern.sng 657.   list L=C(1..2);
./tests_chern.sng 659.   // the Chern classes of the tensor product of a vector bundle E of rank 3
./tests_chern.sng 661.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 663.   // and a vector bundle F of rank 2 with Chern classes C(1) and C(2):
./tests_chern.sng 665.   list rez= chProd(3, l, 2, L) ;
./tests_chern.sng 667.   ensure(rez[1]==   2*c(1)+3*C(1));
./tests_chern.sng 669.   ensure(rez[2]==  c(1)^2+5*c(1)*C(1)+3*C(1)^2+2*c(2)+3*C(2));
./tests_chern.sng 671.   ensure(rez[3]==   2*c(1)^2*C(1)+4*c(1)*C(1)^2+C(1)^3+2*c(1)*c(2)+4*c(2)*C(1)+4*c(1)*C(2)+6*C(1)*C(2)+2*c(3));
./tests_chern.sng 673.   ensure(rez[4]==  c(1)^2*C(1)^2+c(1)*C(1)^3+3*c(1)*c(2)*C(1)+3*c(2)*C(1)^2+2*c(1)^2*C(2)+6*c(1)*C(1)*C(2)+3*C(1)^2*C(2)+c(2)^2+2*c(1)*c(3)+3*c(3)*C(1)+3*C(2)^2);
./tests_chern.sng 675.   ensure(rez[5]==  c(1)*c(2)*C(1)^2+c(2)*C(1)^3+2*c(1)^2*C(1)*C(2)+2*c(1)*C(1)^2*C(2)+c(2)^2*C(1)+2*c(1)*c(3)*C(1)+3*c(3)*C(1)^2+2*c(1)*c(2)*C(2)+2*c(1)*C(2)^2+3*C(1)*C(2)^2+2*c(2)*c(3)-6*c(3)*C(2));
./tests_chern.sng 677.   ensure(rez[6]==  c(1)*c(3)*C(1)^2+c(3)*C(1)^3+c(1)*c(2)*C(1)*C(2)+c(2)*C(1)^2*C(2)+c(1)^2*C(2)^2+c(1)*C(1)*C(2)^2+c(2)*c(3)*C(1)+c(2)^2*C(2)-2*c(1)*c(3)*C(2)-3*c(3)*C(1)*C(2)-2*c(2)*C(2)^2+C(2)^3+c(3)^2);
./tests_chern.sng 679.   // the first two Chern classes of the tensor product
./tests_chern.sng 681.   // of a vector bundle E of rank r with Chern classes c(1) and c(2)
./tests_chern.sng 683.   // and a vector bundle G of rank R with Chern classes C(1) and C(2)
./tests_chern.sng 685.   // this gives the Chern classes of a tensor product on a complex surface
./tests_chern.sng 687.   l=c(1..2);
./tests_chern.sng 689.   L=C(1..2);
./tests_chern.sng 691.   rez= chProd(r, l, R, L, 2 );
./tests_chern.sng 693.   ensure(rez[1]==   R*c(1)+r*C(1));
./tests_chern.sng 695.   ensure(rez[2]==   1/2*R^2*c(1)^2+r*R*c(1)*C(1)+1/2*r^2*C(1)^2-1/2*R*c(1)^2-1/2*r*C(1)^2+R*c(2)-c(1)*C(1)+r*C(2));
./tests_chern.sng 697.   return(check(s));
./tests_chern.sng 699. 
./tests_chern.sng 701. }
./tests_chern.sng 702> 
./tests_chern.sng 703. proc test_chProdE()
./tests_chern.sng 704. {
./tests_chern.sng 705.   string s="chProdE()";
./tests_chern.sng 707.   ring H = 0, ( c(1..3), C(1..2) ), dp;
./tests_chern.sng 709.   list l=c(1..3);
./tests_chern.sng 711.   list L=C(1..2);
./tests_chern.sng 713.   // the Chern classes of the tensor product of a vector bundle E of rank 3
./tests_chern.sng 715.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 717.   // and a vector bundle F of rank 2 with Chern classes C(1) and C(2):
./tests_chern.sng 719.   list rez= chProdE(l,  L);
./tests_chern.sng 721.   ensure(rez[1]==   2*c(1)+3*C(1));
./tests_chern.sng 723.   ensure(rez[2]==   c(1)^2+5*c(1)*C(1)+3*C(1)^2+2*c(2)+3*C(2));
./tests_chern.sng 725.   ensure(rez[3]==   2*c(1)^2*C(1)+4*c(1)*C(1)^2+C(1)^3+2*c(1)*c(2)+4*c(2)*C(1)+4*c(1)*C(2)+6*C(1)*C(2)+2*c(3));
./tests_chern.sng 727.   ensure(rez[4]==   c(1)^2*C(1)^2+c(1)*C(1)^3+3*c(1)*c(2)*C(1)+3*c(2)*C(1)^2+2*c(1)^2*C(2)+6*c(1)*C(1)*C(2)+3*C(1)^2*C(2)+c(2)^2+2*c(1)*c(3)+3*c(3)*C(1)+3*C(2)^2);
./tests_chern.sng 729.   ensure(rez[5]==   c(1)*c(2)*C(1)^2+c(2)*C(1)^3+2*c(1)^2*C(1)*C(2)+2*c(1)*C(1)^2*C(2)+c(2)^2*C(1)+2*c(1)*c(3)*C(1)+3*c(3)*C(1)^2+2*c(1)*c(2)*C(2)+2*c(1)*C(2)^2+3*C(1)*C(2)^2+2*c(2)*c(3)-6*c(3)*C(2));
./tests_chern.sng 731.   ensure(rez[6]==   c(1)*c(3)*C(1)^2+c(3)*C(1)^3+c(1)*c(2)*C(1)*C(2)+c(2)*C(1)^2*C(2)+c(1)^2*C(2)^2+c(1)*C(1)*C(2)^2+c(2)*c(3)*C(1)+c(2)^2*C(2)-2*c(1)*c(3)*C(2)-3*c(3)*C(1)*C(2)-2*c(2)*C(2)^2+C(2)^3+c(3)^2);
./tests_chern.sng 733.   return(check(s));
./tests_chern.sng 735. }
./tests_chern.sng 736> 
./tests_chern.sng 737. proc test_chProdL()
./tests_chern.sng 738. {
./tests_chern.sng 739.   string s="chProdL()";
./tests_chern.sng 741.   // The Chern classes of the tensor product of a vector bundle of rank 3
./tests_chern.sng 743.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 745.   // Chern class C(1)
./tests_chern.sng 747.   ring r = 0, ( c(1..3), C(1)), dp;
./tests_chern.sng 749.   list c=c(1..3);
./tests_chern.sng 751.   list C=C(1);
./tests_chern.sng 753.   list rez= chProdL(3,c,1,C);
./tests_chern.sng 755.   ensure(rez[1]==  c(1)+3*C(1));
./tests_chern.sng 757.   ensure(rez[2]==  2*c(1)*C(1)+3*C(1)^2+c(2));
./tests_chern.sng 759.   ensure(rez[3]==  c(1)*C(1)^2+C(1)^3+c(2)*C(1)+c(3));
./tests_chern.sng 761.   return(check(s));
./tests_chern.sng 763. }
./tests_chern.sng 764> 
./tests_chern.sng 765. 
./tests_chern.sng 766. proc test_chProdLP()
./tests_chern.sng 767. {
./tests_chern.sng 768.   string s="chProdLP()";
./tests_chern.sng 770.   // The total Chern class of the tensor product of a vector bundle of rank 3
./tests_chern.sng 772.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 774.   // Chern class C(1)
./tests_chern.sng 776.   ring r = 0, ( c(1..3), C(1)), ws(1,2,3, 1);
./tests_chern.sng 778.   list c=c(1..3);
./tests_chern.sng 780.   list C=C(1);
./tests_chern.sng 782.   poly rez= chProdLP(3,c,1,C);
./tests_chern.sng 784.   ensure(rez==1+c(1)+3*C(1)+c(2)+2*c(1)*C(1)+3*C(1)^2+c(3)+c(2)*C(1)+c(1)*C(1)^2+C(1)^3);
./tests_chern.sng 786.   return(check(s));
./tests_chern.sng 788. }
./tests_chern.sng 789> 
./tests_chern.sng 790. proc test_chProdM()
./tests_chern.sng 791. {
./tests_chern.sng 792.   string s="chProdM()";
./tests_chern.sng 794.   // The Chern classes of the tensor product of a vector bundle of rank 3
./tests_chern.sng 796.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 798.   // Chern class C(1)
./tests_chern.sng 800.   ring r = 0, ( c(1..3), C(1)), dp;
./tests_chern.sng 802.   list c=c(1..3);
./tests_chern.sng 804.   list C=C(1);
./tests_chern.sng 806.   list rez= chProdM(3,c,1,C);
./tests_chern.sng 808.   ensure(rez[1]==  c(1)+3*C(1));
./tests_chern.sng 810.   ensure(rez[2]==  2*c(1)*C(1)+3*C(1)^2+c(2));
./tests_chern.sng 812.   ensure(rez[3]==  c(1)*C(1)^2+C(1)^3+c(2)*C(1)+c(3));
./tests_chern.sng 814.   return(check(s));
./tests_chern.sng 816. }
./tests_chern.sng 817> 
./tests_chern.sng 818. 
./tests_chern.sng 819. proc test_chProdMP()
./tests_chern.sng 820. {
./tests_chern.sng 821.   string s="chProdMP()";
./tests_chern.sng 823.   // The total Chern class of the tensor product of a vector bundle of rank 3
./tests_chern.sng 825.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 827.   // Chern class C(1)
./tests_chern.sng 829.   ring r = 0, ( c(1..3), C(1)), ws(1,2,3, 1);
./tests_chern.sng 831.   list c=c(1..3);
./tests_chern.sng 833.   list C=C(1);
./tests_chern.sng 835.   poly rez= chProdMP(3,c,1,C);
./tests_chern.sng 837.   ensure(rez==1+c(1)+3*C(1)+c(2)+2*c(1)*C(1)+3*C(1)^2+c(3)+c(2)*C(1)+c(1)*C(1)^2+C(1)^3);
./tests_chern.sng 839.   return(check(s));
./tests_chern.sng 841. }
./tests_chern.sng 842> 
./tests_chern.sng 843. proc test_ChernRootsHom()
./tests_chern.sng 844. {
./tests_chern.sng 845.   string s="ChernRootsHom()";
./tests_chern.sng 847.   ring r=0, (a(1..2), b(1..3)), dp;
./tests_chern.sng 849.   list l=a(1..2);
./tests_chern.sng 851.   list L=b(1..3);
./tests_chern.sng 853.   // Let E be a vector bundle with Chern roots a(1). a(2),
./tests_chern.sng 855.   // let F be a vector bundle with CHern roots b(1), b(2), b(3).
./tests_chern.sng 857.   // Then the Chern roots of Hom(E, F) are
./tests_chern.sng 859.   list rez=ChernRootsHom(l, L);
./tests_chern.sng 861.   ensure(rez[1]== -a(1)+b(1));
./tests_chern.sng 863.   ensure(rez[2]==   -a(1)+b(2));
./tests_chern.sng 865.   ensure(rez[3]==   -a(1)+b(3));
./tests_chern.sng 867.   ensure(rez[4]==   -a(2)+b(1));
./tests_chern.sng 869.   ensure(rez[5]==   -a(2)+b(2));
./tests_chern.sng 871.   ensure(rez[6]==   -a(2)+b(3));
./tests_chern.sng 873.   return(check(s));
./tests_chern.sng 875. 
./tests_chern.sng 877. }
./tests_chern.sng 878> 
./tests_chern.sng 879. proc test_chHom()
./tests_chern.sng 880. {
./tests_chern.sng 881.   string s="chHom()";
./tests_chern.sng 883.   ring H = 0, ( r, R, c(1..3), C(1..2) ), dp;
./tests_chern.sng 885.   list l=c(1..3);
./tests_chern.sng 887.   list L=C(1..2);
./tests_chern.sng 889.   // the Chern classes of Hom(E, F) for a vector bundle E of rank 3
./tests_chern.sng 891.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 893.   // and a vector bundle F of rank 2 with Chern classes C(1) and C(2):
./tests_chern.sng 895.   list rez= chHom(3, l, 2, L);
./tests_chern.sng 897.   ensure(rez[1]==  -2*c(1)+3*C(1));
./tests_chern.sng 899.   ensure(rez[2]==  c(1)^2-5*c(1)*C(1)+3*C(1)^2+2*c(2)+3*C(2));
./tests_chern.sng 901.   ensure(rez[3]==  2*c(1)^2*C(1)-4*c(1)*C(1)^2+C(1)^3-2*c(1)*c(2)+4*c(2)*C(1)-4*c(1)*C(2)+6*C(1)*C(2)-2*c(3));
./tests_chern.sng 903.   ensure(rez[4]==  c(1)^2*C(1)^2-c(1)*C(1)^3-3*c(1)*c(2)*C(1)+3*c(2)*C(1)^2+2*c(1)^2*C(2)-6*c(1)*C(1)*C(2)+3*C(1)^2*C(2)+c(2)^2+2*c(1)*c(3)-3*c(3)*C(1)+3*C(2)^2);
./tests_chern.sng 905.   ensure(rez[5]==  -c(1)*c(2)*C(1)^2+c(2)*C(1)^3+2*c(1)^2*C(1)*C(2)-2*c(1)*C(1)^2*C(2)+c(2)^2*C(1)+2*c(1)*c(3)*C(1)-3*c(3)*C(1)^2-2*c(1)*c(2)*C(2)-2*c(1)*C(2)^2+3*C(1)*C(2)^2-2*c(2)*c(3)+6*c(3)*C(2));
./tests_chern.sng 907.   ensure(rez[6]==  c(1)*c(3)*C(1)^2-c(3)*C(1)^3-c(1)*c(2)*C(1)*C(2)+c(2)*C(1)^2*C(2)+c(1)^2*C(2)^2-c(1)*C(1)*C(2)^2-c(2)*c(3)*C(1)+c(2)^2*C(2)-2*c(1)*c(3)*C(2)+3*c(3)*C(1)*C(2)-2*c(2)*C(2)^2+C(2)^3+c(3)^2);
./tests_chern.sng 909.   
./tests_chern.sng 911.   // the first two Chern classes of Hom(E, F) for a vector bundle E of rank r
./tests_chern.sng 913.   // with Chern classes c(1) and c(2)
./tests_chern.sng 915.   // and a vector bundle G of rank R with Chern classes C(1) and C(2)
./tests_chern.sng 917.   // this gives the Chern classes of a tensor product on a complex surface
./tests_chern.sng 919.   l=c(1..2);
./tests_chern.sng 921.   L=C(1..2);
./tests_chern.sng 923.   rez= chHom(r, l, R, L, 2 ) ;
./tests_chern.sng 925.   ensure(rez[1]==  -R*c(1)+r*C(1));
./tests_chern.sng 927.   ensure(rez[2]==   1/2*R^2*c(1)^2-r*R*c(1)*C(1)+1/2*r^2*C(1)^2-1/2*R*c(1)^2-1/2*r*C(1)^2+R*c(2)+c(1)*C(1)+r*C(2));
./tests_chern.sng 929.   return(check(s));
./tests_chern.sng 931. }
./tests_chern.sng 932> 
./tests_chern.sng 933. proc test_ChernRootsSymm()
./tests_chern.sng 934. {
./tests_chern.sng 935.   string s="ChernRootsSymm()"; 
./tests_chern.sng 937.   ring r=0, (a(1..3)), dp;
./tests_chern.sng 939.   list l=a(1..3);
./tests_chern.sng 941.   // the Chern roots of the second symmetric power of a vector bundle
./tests_chern.sng 943.   // with Chern  roots a(1), a(2), a(3)
./tests_chern.sng 945.   list rez= ChernRootsSymm(2, l) ;
./tests_chern.sng 947.   ensure(rez[1]==   2*a(1));
./tests_chern.sng 949.   ensure(rez[2]==   a(1)+a(2));
./tests_chern.sng 951.   ensure(rez[3]==   a(1)+a(3));
./tests_chern.sng 953.   ensure(rez[4]==   2*a(2));
./tests_chern.sng 955.   ensure(rez[5]==   a(2)+a(3));
./tests_chern.sng 957.   ensure(rez[6]==   2*a(3));
./tests_chern.sng 959.   return(check(s));
./tests_chern.sng 961. }
./tests_chern.sng 962> 
./tests_chern.sng 963. proc test_ChernRootsWedge()
./tests_chern.sng 964. {
./tests_chern.sng 965.   string s="ChernRootsWedge()";
./tests_chern.sng 967.   ring r=0, (a(1..3)), dp;
./tests_chern.sng 969.   list l=a(1..3);
./tests_chern.sng 971.   // the Chern roots of the second exterior power of a vector bundle
./tests_chern.sng 973.   // with Chern  roots a(1), a(2), a(3)
./tests_chern.sng 975.   list rez= ChernRootsWedge(2, l);
./tests_chern.sng 977.   ensure(rez[1]== a(2)+a(3));
./tests_chern.sng 979.   ensure(rez[2]==   a(1)+a(3));
./tests_chern.sng 981.   ensure(rez[3]==   a(1)+a(2));
./tests_chern.sng 983.   return(check(s));
./tests_chern.sng 985. }
./tests_chern.sng 986> 
./tests_chern.sng 987. proc test_chSymm()
./tests_chern.sng 988. {
./tests_chern.sng 989.   string s="chSymm()";
./tests_chern.sng 991.   ring r=0, (c(1..5)), dp;
./tests_chern.sng 993.   list l=c(1..5);
./tests_chern.sng 995.   // the rank and the Chern classes of the second symmetric power of a vector bundle of rank 3
./tests_chern.sng 997.   list rez= chSymm(2, 3, l);
./tests_chern.sng 999.   // the rank should be 6
./tests_chern.sng 1001.   ensure(rez[1]==   6);
./tests_chern.sng 1003.   rez=rez[2];
./tests_chern.sng 1005.   ensure(rez[1]== 4*c(1));
./tests_chern.sng 1007.   ensure(rez[2]== 5*c(1)^2+5*c(2));
./tests_chern.sng 1009.   ensure(rez[3]== 2*c(1)^3+11*c(1)*c(2)+7*c(3));
./tests_chern.sng 1011.   ensure(rez[4]== 6*c(1)^2*c(2)+4*c(2)^2+14*c(1)*c(3));
./tests_chern.sng 1013.   ensure(rez[5]== 4*c(1)*c(2)^2+8*c(1)^2*c(3)+4*c(2)*c(3));
./tests_chern.sng 1015.   ensure(rez[6]== 8*c(1)*c(2)*c(3)-8*c(3)^2);
./tests_chern.sng 1017.   // the rank and the first 3 Chern classes
./tests_chern.sng 1019.   // of the second symmetric power of a vector bundle of rank 5
./tests_chern.sng 1021.   rez= chSymm(2, 5, l, 1, 2, 3);
./tests_chern.sng 1023.   ensure(rez[1]==   15);
./tests_chern.sng 1025.   rez=rez[2];
./tests_chern.sng 1027.   ensure(rez[1]== 6*c(1));
./tests_chern.sng 1029.   ensure(rez[2]== 14*c(1)^2+7*c(2));
./tests_chern.sng 1031.   ensure(rez[3]== 16*c(1)^3+31*c(1)*c(2)+9*c(3));
./tests_chern.sng 1033.   return(check(s));
./tests_chern.sng 1035. }
./tests_chern.sng 1036> 
./tests_chern.sng 1037. proc test_chSymm2L()
./tests_chern.sng 1038. {
./tests_chern.sng 1039.   string s="chSymm2L()";
./tests_chern.sng 1041.   ring r=0, (c(1..2)), dp;
./tests_chern.sng 1043.   list l=c(1..2);
./tests_chern.sng 1045.   // the Chern classes of the second symmetric power of a vector bundle of rank 2
./tests_chern.sng 1047.   list rez= chSymm2L(2, l);
./tests_chern.sng 1049.   ensure(rez[1]== 3);
./tests_chern.sng 1051.   rez=rez[2];
./tests_chern.sng 1053.   ensure(rez[1]== 3*c(1));
./tests_chern.sng 1055.   ensure(rez[2]== 2*c(1)^2+4*c(2));
./tests_chern.sng 1057.   ensure(rez[3]== 4*c(1)*c(2));
./tests_chern.sng 1059.   return(check(s));
./tests_chern.sng 1061. }
./tests_chern.sng 1062> 
./tests_chern.sng 1063. proc test_chSymm2LP()
./tests_chern.sng 1064. {
./tests_chern.sng 1065.   string s="chSymm2LP()";
./tests_chern.sng 1067.   ring r=0, (c(1..2)), ws(1, 2);
./tests_chern.sng 1069.   list l=c(1..2);
./tests_chern.sng 1071.   // the total Chern class of the second symmetric power of a vector bundle of rank 2
./tests_chern.sng 1073.   poly rez=chSymm2LP(2, l);
./tests_chern.sng 1075.   ensure(rez==1+3*c(1)+2*c(1)^2+4*c(2)+4*c(1)*c(2));
./tests_chern.sng 1077.   return(check(s));
./tests_chern.sng 1079. }
./tests_chern.sng 1080> 
./tests_chern.sng 1081. 
./tests_chern.sng 1082. proc test_chWedge()
./tests_chern.sng 1083. {
./tests_chern.sng 1084.   string s="chWedge()";
./tests_chern.sng 1086.   ring r=0, (c(1..5)), dp;
./tests_chern.sng 1088.   list l=c(1..5);
./tests_chern.sng 1090.   // the rank and the Chern classes of the second exterior power of a vector bundle of rank 3
./tests_chern.sng 1092.   list rez=chWedge(2, 3, l);
./tests_chern.sng 1094.   ensure(rez[1]== 3);
./tests_chern.sng 1096.   rez=rez[2];
./tests_chern.sng 1098.   ensure(rez[1]== 2*c(1));
./tests_chern.sng 1100.   ensure(rez[2]== c(1)^2+c(2));
./tests_chern.sng 1102.   ensure(rez[3]== c(1)*c(2)-c(3));
./tests_chern.sng 1104.   // the rank and the first 3 Chern classes
./tests_chern.sng 1106.   // of the fourth exterior power of a vector bundle of rank 5
./tests_chern.sng 1108.   rez= chWedge(4, 5, l, 1, 2, 3);
./tests_chern.sng 1110.   ensure(rez[1]== 5);
./tests_chern.sng 1112.   rez=rez[2];
./tests_chern.sng 1114.   ensure(rez[1]==4*c(1));
./tests_chern.sng 1116.   ensure(rez[2]==6*c(1)^2+c(2));
./tests_chern.sng 1118.   ensure(rez[3]==  4*c(1)^3+3*c(1)*c(2)-c(3));
./tests_chern.sng 1120.   return(check(s));
./tests_chern.sng 1122. }
./tests_chern.sng 1123> 
./tests_chern.sng 1124. proc test_chWedge2L()
./tests_chern.sng 1125. {
./tests_chern.sng 1126.   string s="chWedge2L()";
./tests_chern.sng 1128.   ring r=0, (c(1..3)), dp;
./tests_chern.sng 1130.   list l=c(1..3);
./tests_chern.sng 1132.   // the Chern classes of the second exterior power of a vector bundle of rank 3
./tests_chern.sng 1134.   list rez=chWedge2L(3, l);
./tests_chern.sng 1136.   ensure(rez[1]== 3);
./tests_chern.sng 1138.   rez=rez[2];
./tests_chern.sng 1140.   ensure(rez[1]== 2*c(1));
./tests_chern.sng 1142.   ensure(rez[2]== c(1)^2+c(2));
./tests_chern.sng 1144.   ensure(rez[3]== c(1)*c(2)-c(3));
./tests_chern.sng 1146.   return(check(s));
./tests_chern.sng 1148. }
./tests_chern.sng 1149> 
./tests_chern.sng 1150. proc test_chWedge2LP()
./tests_chern.sng 1151. {
./tests_chern.sng 1152. string s="chWedge2LP()";
./tests_chern.sng 1154.   ring r=0, (c(1..3)), ws(1,2,3);
./tests_chern.sng 1156.   list l=c(1..3);
./tests_chern.sng 1158.   // the total Chern class of the second exterior power of a vector bundle of rank 3
./tests_chern.sng 1160.   poly rez=chWedge2LP(3, l);
./tests_chern.sng 1162.   ensure(rez==1+2*c(1)+c(1)^2+c(2)+c(1)*c(2)-c(3) );
./tests_chern.sng 1164.   return(check(s));
./tests_chern.sng 1166. }
./tests_chern.sng 1167> 
./tests_chern.sng 1168. proc test_todd()
./tests_chern.sng 1169. {
./tests_chern.sng 1170.   string s="todd()";
./tests_chern.sng 1172.   // the terms of the Todd class up to degree 5
./tests_chern.sng 1174.   // in terms of the Chern classes c(1), c(2), c(3), c(4), c(5)
./tests_chern.sng 1176.   ring r=0, (c(1..5)), dp;
./tests_chern.sng 1178.   list l=c(1..5);
./tests_chern.sng 1180.   list rez= todd( l );
./tests_chern.sng 1182.   ensure(rez[1]== 1/2*c(1));
./tests_chern.sng 1184.   ensure(rez[2]==  1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1186.   ensure(rez[3]== 1/24*c(1)*c(2));
./tests_chern.sng 1188.   ensure(rez[4]==   -1/720*c(1)^4+1/180*c(1)^2*c(2)+1/240*c(2)^2+1/720*c(1)*c(3)-1/720*c(4));
./tests_chern.sng 1190.   ensure(rez[5]==   -1/1440*c(1)^3*c(2)+1/480*c(1)*c(2)^2+1/1440*c(1)^2*c(3)-1/1440*c(1)*c(4));
./tests_chern.sng 1192.   // in the same situation compute only first two terms
./tests_chern.sng 1194.   rez= todd(l, 2);
./tests_chern.sng 1196.   ensure(rez[1]== 1/2*c(1));
./tests_chern.sng 1198.   ensure(rez[2]==  1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1200. 
./tests_chern.sng 1202.   // compute the first 5 terms corresponding to the Chern classes c(1), c(2)
./tests_chern.sng 1204.   l=c(1..2);
./tests_chern.sng 1206.   rez= todd(l, 5) ;
./tests_chern.sng 1208.   ensure(rez[1]==  1/2*c(1));
./tests_chern.sng 1210.   ensure(rez[2]==    1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1212.   ensure(rez[3]==   1/24*c(1)*c(2));
./tests_chern.sng 1214.   ensure(rez[4]==   -1/720*c(1)^4+1/180*c(1)^2*c(2)+1/240*c(2)^2);
./tests_chern.sng 1216.   ensure(rez[5]==   -1/1440*c(1)^3*c(2)+1/480*c(1)*c(2)^2);
./tests_chern.sng 1218.   return(check(s));
./tests_chern.sng 1220. }
./tests_chern.sng 1221> 
./tests_chern.sng 1222. 
./tests_chern.sng 1223. proc test_toddE()
./tests_chern.sng 1224. {
./tests_chern.sng 1225.   string s="toddE()";
./tests_chern.sng 1227.   // first  3 terms of the Todd class in terms of the Chern classes c(1), c(2), c(3)
./tests_chern.sng 1229.   ring r=0, (c(1..3)), dp;
./tests_chern.sng 1231.   list l;
./tests_chern.sng 1233.   //first term
./tests_chern.sng 1235.   l=c(1);
./tests_chern.sng 1237.   poly rez= toddE( l );
./tests_chern.sng 1239.   ensure(rez==1/2*c(1));
./tests_chern.sng 1241.   // second term
./tests_chern.sng 1243.   l=c(1..2);
./tests_chern.sng 1245.   rez= toddE( l );
./tests_chern.sng 1247.   ensure(rez== 1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1249.   // third term
./tests_chern.sng 1251.   l=c(1..3);
./tests_chern.sng 1253.   rez= toddE( l );
./tests_chern.sng 1255.   ensure(rez==1/24*c(1)*c(2));
./tests_chern.sng 1257.   return(check(s));
./tests_chern.sng 1259. }
./tests_chern.sng 1260> 
./tests_chern.sng 1261. proc test_Bern()
./tests_chern.sng 1262. {
./tests_chern.sng 1263.   string s="Bern()";
./tests_chern.sng 1265.   // first 10 Bernoulli numbers: B(0), ..., B(9)
./tests_chern.sng 1267.   ring r=0,(t), dp;
./tests_chern.sng 1269.   list rez= Bern(9);
./tests_chern.sng 1271.   ensure(rez[1]==1);
./tests_chern.sng 1273.   ensure(rez[2]==1/2);
./tests_chern.sng 1275.   ensure(rez[3]==1/6);
./tests_chern.sng 1277.   ensure(rez[4]==0);
./tests_chern.sng 1279.   ensure(rez[5]==-1/30);
./tests_chern.sng 1281.   ensure(rez[6]==0);
./tests_chern.sng 1283.   ensure(rez[7]==1/42);
./tests_chern.sng 1285.   ensure(rez[8]==0);
./tests_chern.sng 1287.   ensure(rez[9]==-1/30);
./tests_chern.sng 1289.   ensure(rez[10]==0);
./tests_chern.sng 1291.   return(check(s));
./tests_chern.sng 1293. }
./tests_chern.sng 1294> 
./tests_chern.sng 1295. proc test_tdCf()
./tests_chern.sng 1296. {
./tests_chern.sng 1297.   string s="tdCf()"; 
./tests_chern.sng 1299.   // first 5 coefficients
./tests_chern.sng 1301.   ring r=0,(t), dp;
./tests_chern.sng 1303.   list rez= tdCf(4);
./tests_chern.sng 1305.   ensure(rez[1]==1);
./tests_chern.sng 1307.   ensure(rez[2]==1/2);
./tests_chern.sng 1309.   ensure(rez[3]==1/12);
./tests_chern.sng 1311.   ensure(rez[4]==0);
./tests_chern.sng 1313.   ensure(rez[5]==-1/720);
./tests_chern.sng 1315.   return(check(s));
./tests_chern.sng 1317. }
./tests_chern.sng 1318> 
./tests_chern.sng 1319. proc test_tdTerms()
./tests_chern.sng 1320. {
./tests_chern.sng 1321.   string s="tdTerms()";
./tests_chern.sng 1323.   ring r=0, (t), ls;;
./tests_chern.sng 1325.   // the terms of the Todd class of a line bundle with Chern root t up to degree 4
./tests_chern.sng 1327.   list rez=tdTerms(4, t);
./tests_chern.sng 1329.   ensure(rez[1]== 1);
./tests_chern.sng 1331.   ensure(rez[2]==   1/2t);
./tests_chern.sng 1333.   ensure(rez[3]==   1/12t2);
./tests_chern.sng 1335.   ensure(rez[4]==   0);
./tests_chern.sng 1337.   ensure(rez[5]==   -1/720t4);
./tests_chern.sng 1339.   return(check(s));
./tests_chern.sng 1341. }
./tests_chern.sng 1342> 
./tests_chern.sng 1343. proc test_tdFactor()
./tests_chern.sng 1344. {
./tests_chern.sng 1345.   string s="tdFactor()"; 
./tests_chern.sng 1347.   // the Todd class up do degree 4
./tests_chern.sng 1349.   ring r=0,(t), ls;
./tests_chern.sng 1351.   poly rez= tdFactor(4, t);
./tests_chern.sng 1353.   ensure(rez==1+1/2t+1/12t2-1/720t4);
./tests_chern.sng 1355.   return(check(s));
./tests_chern.sng 1357. }
./tests_chern.sng 1358> 
./tests_chern.sng 1359. proc test_cProj()
./tests_chern.sng 1360. {
./tests_chern.sng 1361.   string s="cProj()";
./tests_chern.sng 1363.   ring r=0, (t), dp;
./tests_chern.sng 1365.   // the coefficients of the total Chern class of the complex projective line
./tests_chern.sng 1367.   list rez= cProj(1);
./tests_chern.sng 1369.   ensure(rez[1]==   2);
./tests_chern.sng 1371.   // the coefficients of the total Chern class of the complex projective plane
./tests_chern.sng 1373.   rez= cProj(2) ;
./tests_chern.sng 1375.   ensure(rez[1]==   3);
./tests_chern.sng 1377.   ensure(rez[2]==   3);
./tests_chern.sng 1379.   // the coefficients of the total Chern class of the complex projective space
./tests_chern.sng 1381.   // of dimension three
./tests_chern.sng 1383.   rez= cProj(3) ;
./tests_chern.sng 1385.   ensure(rez[1]==   4);
./tests_chern.sng 1387.   ensure(rez[2]==   6);
./tests_chern.sng 1389.   ensure(rez[3]==   4);
./tests_chern.sng 1391.   return(check(s));
./tests_chern.sng 1393. }
./tests_chern.sng 1394> 
./tests_chern.sng 1395. proc test_chProj()
./tests_chern.sng 1396. {
./tests_chern.sng 1397.   string s="chProj()";
./tests_chern.sng 1399.   ring r=0, (t), dp;
./tests_chern.sng 1401.   // the coefficients of the Chern character of the complex projective line
./tests_chern.sng 1403.   list rez= chProj(1);
./tests_chern.sng 1405.   ensure(rez[1]==1);
./tests_chern.sng 1407.   ensure(rez[2]==2);
./tests_chern.sng 1409.   // the coefficients of the Chern character of the complex projective plane
./tests_chern.sng 1411.   rez= chProj(2) ;
./tests_chern.sng 1413.   ensure(rez[1]==2);
./tests_chern.sng 1415.   ensure(rez[2]==3);
./tests_chern.sng 1417.   ensure(rez[3]==3/2);
./tests_chern.sng 1419.   // the coefficients of the Chern character of the complex 3-dimentional projectice space
./tests_chern.sng 1421.   rez=chProj(3);
./tests_chern.sng 1423.   ensure(rez[1]==3);
./tests_chern.sng 1425.   ensure(rez[2]==4);
./tests_chern.sng 1427.   ensure(rez[3]==2);
./tests_chern.sng 1429.   ensure(rez[4]==2/3);
./tests_chern.sng 1431.   return(check(s));
./tests_chern.sng 1433. }
./tests_chern.sng 1434> 
./tests_chern.sng 1435. proc test_tdProj()
./tests_chern.sng 1436. {
./tests_chern.sng 1437.   string s="tdProj()";
./tests_chern.sng 1439.   ring r=0, (t), dp;
./tests_chern.sng 1441.   // the coefficients of the Todd class of the complex projective line
./tests_chern.sng 1443.   list rez= tdProj(1);
./tests_chern.sng 1445.   ensure(rez[1]==   1);
./tests_chern.sng 1447.   ensure(rez[2]==   1);
./tests_chern.sng 1449.   // the coefficients of the Todd class of the complex projective line
./tests_chern.sng 1451.   rez= tdProj(2);
./tests_chern.sng 1453.   ensure(rez[1]==   1);
./tests_chern.sng 1455.   ensure(rez[2]==   3/2);
./tests_chern.sng 1457.   ensure(rez[3]==   1);
./tests_chern.sng 1459.   // the coefficients of the Todd class of the complex projective line
./tests_chern.sng 1461.   rez= tdProj(3);
./tests_chern.sng 1463.   ensure(rez[1]==  1);
./tests_chern.sng 1465.   ensure(rez[2]==   2);
./tests_chern.sng 1467.   ensure(rez[3]==   11/6);
./tests_chern.sng 1469.   ensure(rez[4]==   1);
./tests_chern.sng 1471.   return(check(s));
./tests_chern.sng 1473. }
./tests_chern.sng 1474> 
./tests_chern.sng 1475. proc test_eulerChProj()
./tests_chern.sng 1476. {
./tests_chern.sng 1477.   string s="eulerChProj()";
./tests_chern.sng 1479.   ring h=0, (r, c(1..3)),  ws(0,1,2,3);
./tests_chern.sng 1481.   list l=c(1..3);
./tests_chern.sng 1483. 
./tests_chern.sng 1485.   // the Euler characteristic of a vector bundle on the projective line
./tests_chern.sng 1487.   poly rez= eulerChProj(1, r, l);
./tests_chern.sng 1489.   ensure(rez==r+c(1));
./tests_chern.sng 1491. 
./tests_chern.sng 1493.   // the Euler characteristic of a vector bundle on the projective plane
./tests_chern.sng 1495.   rez= eulerChProj(2, r, l);
./tests_chern.sng 1497.   ensure(rez==r+3/2*c(1)+1/2*c(1)^2-c(2));
./tests_chern.sng 1499. 
./tests_chern.sng 1501.   // the Euler characteristic of a vector bundle on P_3
./tests_chern.sng 1503.   rez= eulerChProj(3, r, l);
./tests_chern.sng 1505.   ensure(rez==r+11/6*c(1)+c(1)^2-2*c(2)+1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 1507. 
./tests_chern.sng 1509.   // assume now that we have a bundle framed at a subplane of P_3
./tests_chern.sng 1511.   // this implies c(1)=c(2)=0
./tests_chern.sng 1513.   l= 0, 0, c(3);
./tests_chern.sng 1515. 
./tests_chern.sng 1517.   // the Euler characteristic is
./tests_chern.sng 1519.   rez= eulerChProj(3, r, l);
./tests_chern.sng 1521.   ensure(rez==r+1/2*c(3));
./tests_chern.sng 1523.   // which implies that c(3) must be even in this case
./tests_chern.sng 1525.   return(check(s));
./tests_chern.sng 1527. }
./tests_chern.sng 1528> 
./tests_chern.sng 1529. proc test_chNumbersProj()
./tests_chern.sng 1530. {
./tests_chern.sng 1531.   string s="chNumbersProj()";
./tests_chern.sng 1533.   ring h=0, (t), dp;
./tests_chern.sng 1535.   // The Chern numbers of the projective plane P_2:
./tests_chern.sng 1537.   list rez= chNumbersProj(2) ;
./tests_chern.sng 1539.   ensure(rez[1]==9);
./tests_chern.sng 1541.   ensure(rez[2]==   3);
./tests_chern.sng 1543. 
./tests_chern.sng 1545.   // The Chern numbers of P_3:
./tests_chern.sng 1547.   rez=chNumbersProj(3);
./tests_chern.sng 1549.   ensure(rez[1]==   64);
./tests_chern.sng 1551.   ensure(rez[2]==   24);
./tests_chern.sng 1553.   ensure(rez[3]==   4);
./tests_chern.sng 1555.   return(check(s));
./tests_chern.sng 1557. }
./tests_chern.sng 1558> 
./tests_chern.sng 1559. proc test_classpoly()
./tests_chern.sng 1560. {
./tests_chern.sng 1561.   string s="classpoly()";
./tests_chern.sng 1563.   ring r=0, (c(1..5), t), ds;
./tests_chern.sng 1565.   list l=c(1..5);
./tests_chern.sng 1567.   // get the polynomial c(1)*t + c(2)*t^2 + ... + c(5)*t^5
./tests_chern.sng 1569.   poly rez= classpoly(l, t);
./tests_chern.sng 1571.   ensure(rez==c(1)*t+c(2)*t^2+c(3)*t^3+c(4)*t^4+c(5)*t^5);
./tests_chern.sng 1573.   return(check(s));
./tests_chern.sng 1575. }
./tests_chern.sng 1576> 
./tests_chern.sng 1577. proc test_chernPoly()
./tests_chern.sng 1578. {
./tests_chern.sng 1579.   string s="chernPoly()"; 
./tests_chern.sng 1581.   ring r=0, (c(1..5), t), ds;
./tests_chern.sng 1583.   list l=c(1..5);
./tests_chern.sng 1585.   // get the Chern polynomial 1 + c(1)*t + c(2)*t^2 + ... + c(5)*t^5
./tests_chern.sng 1587.   poly rez= chernPoly(l, t);
./tests_chern.sng 1589.   ensure(rez==1+c(1)*t+c(2)*t^2+c(3)*t^3+c(4)*t^4+c(5)*t^5);
./tests_chern.sng 1591.   return(check(s));
./tests_chern.sng 1593. }
./tests_chern.sng 1594> 
./tests_chern.sng 1595. proc test_chernCharPoly()
./tests_chern.sng 1596. {
./tests_chern.sng 1597.   string s="chernCharPoly()";
./tests_chern.sng 1599.   ring h=0, (r, ch(1..5), t), ds;
./tests_chern.sng 1601.   list l=ch(1..5);
./tests_chern.sng 1603.   // get the polynomial r + ch(1)*t + ch(2)*t^2 + ... + ch(5)*t^5
./tests_chern.sng 1605.   poly rez= chernCharPoly(r, l, t);
./tests_chern.sng 1607.   ensure(rez==r+ch(1)*t+ch(2)*t^2+ch(3)*t^3+ch(4)*t^4+ch(5)*t^5);
./tests_chern.sng 1609.   return(check(s));
./tests_chern.sng 1611. }
./tests_chern.sng 1612> 
./tests_chern.sng 1613. proc test_toddPoly()
./tests_chern.sng 1614. {
./tests_chern.sng 1615.   string s="toddPoly()";
./tests_chern.sng 1617.   ring r=0, (td(1..5), c(1..5), t), ds;
./tests_chern.sng 1619.   list l=td(1..5);
./tests_chern.sng 1621.   // get the polynomial 1 + td(1)*t + td(2)*t^2 + ... + td(5)*t^5
./tests_chern.sng 1623.   poly rez= toddPoly(l, t);
./tests_chern.sng 1625.   ensure(rez==1+td(1)*t+td(2)*t^2+td(3)*t^3+td(4)*t^4+td(5)*t^5);
./tests_chern.sng 1627.   return(check(s));
./tests_chern.sng 1629. }
./tests_chern.sng 1630> 
./tests_chern.sng 1631. proc test_rHRR()
./tests_chern.sng 1632. {
./tests_chern.sng 1633.   string s="rHRR()";
./tests_chern.sng 1635.   ring r=0, (td(0..3), ch(0..3)), dp;
./tests_chern.sng 1637.   // Let ch(0), ch(1), ch(2), ch(3) be the terms of the Chern character
./tests_chern.sng 1639.   // of a vector bundle E on a 3-fold X.
./tests_chern.sng 1641.   list c = ch(0..3);
./tests_chern.sng 1643.   // Let td(0), td(1), td(2), td(3) be the terms of the Todd class of X.
./tests_chern.sng 1645.   list t = td(0..3);
./tests_chern.sng 1647.   // Then the highest term of the product ch(E).td(X) is:
./tests_chern.sng 1649.   poly rez= rHRR(3, c, t);
./tests_chern.sng 1651.   ensure(rez==td(3)*ch(0)+td(2)*ch(1)+td(1)*ch(2)+td(0)*ch(3));
./tests_chern.sng 1653.   return(check(s));
./tests_chern.sng 1655. }
./tests_chern.sng 1656> 
./tests_chern.sng 1657. proc test_SchurS()
./tests_chern.sng 1658. {
./tests_chern.sng 1659.   string s="SchurS()";
./tests_chern.sng 1661.   // The Schur polynomial corresponding to the partition 1,2,4
./tests_chern.sng 1663.   // and the Segre classes 1, s(1), s(2),..., s(6)
./tests_chern.sng 1665.   ring r=0,(s(1..6)), dp;
./tests_chern.sng 1667.   list I=1,2,4;
./tests_chern.sng 1669.   list S=s(1..6);
./tests_chern.sng 1671.   poly rez=SchurS(I, S);
./tests_chern.sng 1673.   ensure(rez==s(1)*s(2)*s(4)-s(1)^2*s(5)-s(3)*s(4)+s(1)*s(6));
./tests_chern.sng 1675.   // compare this with the Schur polynomial computed using Chern classes
./tests_chern.sng 1677.   list C=chDual(chern(S));
./tests_chern.sng 1679.   rez= SchurCh(I, C) ;
./tests_chern.sng 1681.   ensure(rez==s(1)*s(2)*s(4)-s(1)^2*s(5)-s(3)*s(4)+s(1)*s(6));
./tests_chern.sng 1683.   return(check(s));
./tests_chern.sng 1685. }
./tests_chern.sng 1686> 
./tests_chern.sng 1687. proc test_SchurCh()
./tests_chern.sng 1688. {
./tests_chern.sng 1689.   string s="SchurCh()";
./tests_chern.sng 1691.   // The Schur polynomial corresponding to the partition 1,2,4
./tests_chern.sng 1693.   // and the Chern classes c(1), c(2), c(3)
./tests_chern.sng 1695.   ring r=0,(c(1..3)), dp;
./tests_chern.sng 1697.   list I=1,2,4;
./tests_chern.sng 1699.   list C=c(1..3);
./tests_chern.sng 1701.   poly rez= SchurCh(I, C);
./tests_chern.sng 1703.   ensure(rez==c(1)^2*c(2)*c(3)-c(2)^2*c(3)-c(1)*c(3)^2);
./tests_chern.sng 1705.   // Compare this with the Schur polynomial computed using Segre classes
./tests_chern.sng 1707.   list S=segre( chDual( list(c(1..3)) ), 6 );
./tests_chern.sng 1709.   rez=SchurS(I,S);
./tests_chern.sng 1711.   ensure(rez==  c(1)^2*c(2)*c(3)-c(2)^2*c(3)-c(1)*c(3)^2);
./tests_chern.sng 1713.   return(check(s));
./tests_chern.sng 1715. }
./tests_chern.sng 1716> 
./tests_chern.sng 1717. proc test_part()
./tests_chern.sng 1718. {
./tests_chern.sng 1719.   string s="part()";
./tests_chern.sng 1721.   // partitions into 3 summands of numbers not exceeding 1
./tests_chern.sng 1723.   list rez= part(3, 1);
./tests_chern.sng 1725.   ensure(rez[1][1]==      0);
./tests_chern.sng 1727.   ensure(rez[1][2]==      0);
./tests_chern.sng 1729.   ensure(rez[1][3]==      0);
./tests_chern.sng 1731. 
./tests_chern.sng 1733.   ensure(rez[2][1]==      0);
./tests_chern.sng 1735.   ensure(rez[2][2]==      0);
./tests_chern.sng 1737.   ensure(rez[2][3]==      1);
./tests_chern.sng 1739. 
./tests_chern.sng 1741.   ensure(rez[3][1]==      0);
./tests_chern.sng 1743.   ensure(rez[3][2]==      1);
./tests_chern.sng 1745.   ensure(rez[3][3]==      1);
./tests_chern.sng 1747. 
./tests_chern.sng 1749.   ensure(rez[4][1]==      1);
./tests_chern.sng 1751.   ensure(rez[4][2]==      1);
./tests_chern.sng 1753.   ensure(rez[4][3]==      1);
./tests_chern.sng 1755. 
./tests_chern.sng 1757.   return(check(s));
./tests_chern.sng 1759. }
./tests_chern.sng 1760> 
./tests_chern.sng 1761. 
./tests_chern.sng 1762. 
./tests_chern.sng 1763. proc test_dualPart()
./tests_chern.sng 1764. {
./tests_chern.sng 1765.   string s="dualPart()";
./tests_chern.sng 1767.   // dual partition to (1, 3, 4):
./tests_chern.sng 1769.   list I = 1, 3, 4;
./tests_chern.sng 1771.   list rez= dualPart(I);
./tests_chern.sng 1773.   ensure(rez[1]==   1);
./tests_chern.sng 1775.   ensure(rez[2]==   2);
./tests_chern.sng 1777.   ensure(rez[3]==   2);
./tests_chern.sng 1779.   ensure(rez[4]==   3);
./tests_chern.sng 1781.   return(check(s));
./tests_chern.sng 1783. }
./tests_chern.sng 1784> 
./tests_chern.sng 1785. proc test_PartC()
./tests_chern.sng 1786. {
./tests_chern.sng 1787.   string s="PartC()";
./tests_chern.sng 1789.   // Complement of the partition (1, 3, 4) with respect to 5
./tests_chern.sng 1791.   list I = 1, 3, 4;
./tests_chern.sng 1793.   list rez= PartC(I, 5);
./tests_chern.sng 1795.   ensure(rez[1]==  1);
./tests_chern.sng 1797.   ensure(rez[2]==   2);
./tests_chern.sng 1799.   ensure(rez[3]==   4);
./tests_chern.sng 1801.   return(check(s));
./tests_chern.sng 1803. }
./tests_chern.sng 1804> 
./tests_chern.sng 1805. proc test_partOver()
./tests_chern.sng 1806. {
./tests_chern.sng 1807.   string s="partOver()";
./tests_chern.sng 1809.   // Partitions over the partition (3, 3, 4) with summands not exceeding 4
./tests_chern.sng 1811.   list I = 3, 3, 4;
./tests_chern.sng 1813.   list rez= partOver(4, I);
./tests_chern.sng 1815.   ensure(rez[1][1] == 3);
./tests_chern.sng 1817.   ensure(rez[1][2] == 3);
./tests_chern.sng 1819.   ensure(rez[1][3] == 4);
./tests_chern.sng 1821. 
./tests_chern.sng 1823.   ensure(rez[2][1] == 3);
./tests_chern.sng 1825.   ensure(rez[2][2] == 4);
./tests_chern.sng 1827.   ensure(rez[2][3] == 4);
./tests_chern.sng 1829. 
./tests_chern.sng 1831.   ensure(rez[3][1] == 4);
./tests_chern.sng 1833.   ensure(rez[3][2] == 4);
./tests_chern.sng 1835.   ensure(rez[3][3] == 4);
./tests_chern.sng 1837.   return(check(s));
./tests_chern.sng 1839. }
./tests_chern.sng 1840> 
./tests_chern.sng 1841. 
./tests_chern.sng 1842. proc test_partUnder()
./tests_chern.sng 1843. {
./tests_chern.sng 1844.   string s="partUnder()";
./tests_chern.sng 1846.   // Partitions under the partition (0, 1, 1)
./tests_chern.sng 1848.   list I = 0, 1, 1;
./tests_chern.sng 1850.   list rez= partUnder(I);
./tests_chern.sng 1852.   ensure(rez[1][1] == 0);
./tests_chern.sng 1854.   ensure(rez[1][2] == 0);
./tests_chern.sng 1856.   ensure(rez[1][3] == 0);
./tests_chern.sng 1858. 
./tests_chern.sng 1860.   ensure(rez[2][1] == 0);
./tests_chern.sng 1862.   ensure(rez[2][2] == 0);
./tests_chern.sng 1864.   ensure(rez[2][3] == 1);
./tests_chern.sng 1866. 
./tests_chern.sng 1868.   ensure(rez[3][1] == 0);
./tests_chern.sng 1870.   ensure(rez[3][2] == 1);
./tests_chern.sng 1872.   ensure(rez[3][3] == 1);
./tests_chern.sng 1874.   return(check(s));
./tests_chern.sng 1876. }
./tests_chern.sng 1877> 
./tests_chern.sng 1878. proc test_SegreA()
./tests_chern.sng 1879. {
./tests_chern.sng 1880.   string s="SegreA()";
./tests_chern.sng 1882.   // Consider a 3-dimensional projective space
./tests_chern.sng 1884.   ring r = 0, (x, y, z, w), dp;
./tests_chern.sng 1886.   // Consider 3 non-coplanar lines trough one point and compute the Segre class
./tests_chern.sng 1888.   ideal I=xy, xz, yz;
./tests_chern.sng 1890.   list rez=SegreA(I);
./tests_chern.sng 1892.   ensure(rez[1]==   0);
./tests_chern.sng 1894.   ensure(rez[2]==   0);
./tests_chern.sng 1896.   ensure(rez[3]==   3);
./tests_chern.sng 1898.   ensure(rez[4]==   -10);
./tests_chern.sng 1900.   // Now consider 3 coplanar lines trough one point and its Segre class
./tests_chern.sng 1902.   ideal J=w, x*y*(x+y);
./tests_chern.sng 1904.   rez=SegreA(J);
./tests_chern.sng 1906.   ensure(rez[1]==   0);
./tests_chern.sng 1908.   ensure(rez[2]==   0);
./tests_chern.sng 1910.   ensure(rez[3]==   3);
./tests_chern.sng 1912.   ensure(rez[4]==   -12);
./tests_chern.sng 1914.   return(check(s));
./tests_chern.sng 1916. }
./tests_chern.sng 1917> 
./tests_chern.sng 1918. proc test_FultonA()
./tests_chern.sng 1919. {
./tests_chern.sng 1920.   string s="FultonA()";
./tests_chern.sng 1922.   // Consider a 3-dimensional projective space
./tests_chern.sng 1924.   ring r = 0, (x, y, z, w), dp;
./tests_chern.sng 1926.   // Consider 3 non-coplanar lines trough one point and compute the Fulton class
./tests_chern.sng 1928.   ideal I=xy, xz, yz;
./tests_chern.sng 1930.   list rez=FultonA(I);
./tests_chern.sng 1932.   ensure(rez[1]==   0);
./tests_chern.sng 1934.   ensure(rez[2]==   0);
./tests_chern.sng 1936.   ensure(rez[3]==   3);
./tests_chern.sng 1938.   ensure(rez[4]==   2);
./tests_chern.sng 1940.   // Now consider 3 coplanar lines trough one point and its Fulton class
./tests_chern.sng 1942.   ideal J=w, x*y*(x+y);
./tests_chern.sng 1944.   rez=FultonA(J);
./tests_chern.sng 1946.   ensure(rez[1]==   0);
./tests_chern.sng 1948.   ensure(rez[2]==   0);
./tests_chern.sng 1950.   ensure(rez[3]==   3);
./tests_chern.sng 1952.   ensure(rez[4]==   0);
./tests_chern.sng 1954.   return(check(s));
./tests_chern.sng 1956. }
./tests_chern.sng 1957> 
./tests_chern.sng 1958. 
./tests_chern.sng 1959. proc test_CSMA()
./tests_chern.sng 1960. {
./tests_chern.sng 1961.   string s="CSMA()";
./tests_chern.sng 1963.   // consider the projective plane with homogeneous coordinates x, y, z
./tests_chern.sng 1965.   ring r = 0, (x, y, z), dp;
./tests_chern.sng 1967.   // the Chern-Schwartz-MacPherson class of a smooth cubic:
./tests_chern.sng 1969.   ideal I=x3+y3+z3;
./tests_chern.sng 1971.   list rez=CSMA(I);
./tests_chern.sng 1973.   ensure(rez[1]==   0);
./tests_chern.sng 1975.   ensure(rez[2]==   3);
./tests_chern.sng 1977.   ensure(rez[3]==   0);
./tests_chern.sng 1979.   // the Chern-Schwartz-MacPherson class of singular cubic
./tests_chern.sng 1981.   // that is a union of 3 non-collinear lines:
./tests_chern.sng 1983.   ideal J=x*y*z;
./tests_chern.sng 1985.   rez= CSMA(J);
./tests_chern.sng 1987.   ensure(rez[1]==   0);
./tests_chern.sng 1989.   ensure(rez[2]==   3);
./tests_chern.sng 1991.   ensure(rez[3]==   3);
./tests_chern.sng 1993.   // the Chern-Schwartz-MacPherson class of singular cubic
./tests_chern.sng 1995.   // that is a union of 3 lines passing through one point
./tests_chern.sng 1997.   ideal K=x*y*(x+y);
./tests_chern.sng 1999.   rez=CSMA(K);
./tests_chern.sng 2001.   ensure(rez[1]==   0);
./tests_chern.sng 2003.   ensure(rez[2]==   3);
./tests_chern.sng 2005.   ensure(rez[3]==   4);
./tests_chern.sng 2007.   return(check(s));
./tests_chern.sng 2009. }
./tests_chern.sng 2010> 
./tests_chern.sng 2011. proc test_EulerAff()
./tests_chern.sng 2012. {
./tests_chern.sng 2013.   string s="EulerAff()";
./tests_chern.sng 2015.   ring r = 0, (x, y), dp;
./tests_chern.sng 2017.   // compute the Euler characteristic of the affine ellipric curve y^2=x^3+x+1;
./tests_chern.sng 2019.   ideal I=y2-x3-x-1;
./tests_chern.sng 2021.   ensure(EulerAff(I)==-1);
./tests_chern.sng 2023.   return(check(s));
./tests_chern.sng 2025. }
./tests_chern.sng 2026> 
./tests_chern.sng 2027. proc test_EulerAffBugFix()
./tests_chern.sng 2028. {
./tests_chern.sng 2029.   string s="EulerAffBugFix()";
./tests_chern.sng 2031.   ring r = 0, (a, b, c, d), dp;
./tests_chern.sng 2033.   // compute the Euler characteristic of the affine ellipric curve a3+b3+c3+d3+2*b*d=0;
./tests_chern.sng 2035.   ideal I=a3+b3+c3+d3+2*b*d;
./tests_chern.sng 2037.   ensure(EulerAff(I)==-11);
./tests_chern.sng 2039.   return(check(s));
./tests_chern.sng 2041. }
./tests_chern.sng 2042> 
./tests_chern.sng 2043. 
./tests_chern.sng 2044. proc test_EulerProj()
./tests_chern.sng 2045. {
./tests_chern.sng 2046.   string s="EulerProj()";
./tests_chern.sng 2048.   // consider the projective plane with homogeneous coordinates x, y, z
./tests_chern.sng 2050.   ring r = 0, (x, y, z), dp;
./tests_chern.sng 2052.   // Euler characteristic of a smooth cubic:
./tests_chern.sng 2054.   ideal I=x3+y3+z3;
./tests_chern.sng 2056.   ensure(EulerProj(I)==0);
./tests_chern.sng 2058.   // Euler characteritic of 3 non-collinear lines:
./tests_chern.sng 2060.   ideal J=x*y*z;
./tests_chern.sng 2062.   ensure(EulerProj(J)==3);
./tests_chern.sng 2064.   // Euler characteristic of 3 lines passing through one point
./tests_chern.sng 2066.   ideal K=x*y*(x+y);
./tests_chern.sng 2068.   ensure(EulerProj(K)==4);
./tests_chern.sng 2070.   return(check(s));
./tests_chern.sng 2072. }
./tests_chern.sng 2073> 
./tests_chern.sng 2074. proc test_full()
./tests_chern.sng 2075. {
./tests_chern.sng 2076. return(
./tests_chern.sng 2078. test_symm()*
./tests_chern.sng 2080. test_symNsym()*
./tests_chern.sng 2082. test_symNsymBugFix()*
./tests_chern.sng 2084. test_symNsymRandomData()*
./tests_chern.sng 2086. test_CompleteHomog()*
./tests_chern.sng 2088. test_segre()*
./tests_chern.sng 2090. test_chern()*
./tests_chern.sng 2092. test_chNum()*
./tests_chern.sng 2094. test_chNumbers()*
./tests_chern.sng 2096. test_sum_of_powers()*
./tests_chern.sng 2098. test_powSumSym()*
./tests_chern.sng 2100. test_chAll()*
./tests_chern.sng 2102. test_chAllInv()*
./tests_chern.sng 2104. test_chHE()*
./tests_chern.sng 2106. test_ChernRootsSum()*
./tests_chern.sng 2108. test_chSum()*
./tests_chern.sng 2110. test_ChernRootsDual()*
./tests_chern.sng 2112. test_chDual()*
./tests_chern.sng 2114. test_ChernRootsProd()*
./tests_chern.sng 2116. test_chProd()*
./tests_chern.sng 2118. test_chProdE()*
./tests_chern.sng 2120. test_chProdL()*
./tests_chern.sng 2122. test_chProdLP()*
./tests_chern.sng 2124. test_chProdM()*
./tests_chern.sng 2126. test_chProdMP()*
./tests_chern.sng 2128. test_ChernRootsHom()*
./tests_chern.sng 2130. test_chHom()*
./tests_chern.sng 2132. test_ChernRootsSymm()*
./tests_chern.sng 2134. test_ChernRootsWedge()*
./tests_chern.sng 2136. test_chSymm()*
./tests_chern.sng 2138. test_chSymm2L()*
./tests_chern.sng 2140. test_chSymm2LP()*
./tests_chern.sng 2142. test_chWedge()*
./tests_chern.sng 2144. test_chWedge2L()*
./tests_chern.sng 2146. test_chWedge2LP()*
./tests_chern.sng 2148. test_todd()*
./tests_chern.sng 2150. test_toddE()*
./tests_chern.sng 2152. test_Bern()*
./tests_chern.sng 2154. test_tdCf()*
./tests_chern.sng 2156. test_tdTerms()*
./tests_chern.sng 2158. test_tdFactor()*
./tests_chern.sng 2160. test_cProj()*
./tests_chern.sng 2162. test_chProj()*
./tests_chern.sng 2164. test_tdProj()*
./tests_chern.sng 2166. test_eulerChProj()*
./tests_chern.sng 2168. test_chNumbersProj()*
./tests_chern.sng 2170. test_classpoly()*
./tests_chern.sng 2172. test_chernPoly()*
./tests_chern.sng 2174. test_chernCharPoly()*
./tests_chern.sng 2176. test_toddPoly()*
./tests_chern.sng 2178. test_rHRR()*
./tests_chern.sng 2180. test_SchurS()*
./tests_chern.sng 2182. test_SchurCh()*
./tests_chern.sng 2184. test_part()*
./tests_chern.sng 2186. test_dualPart()*
./tests_chern.sng 2188. test_PartC()*
./tests_chern.sng 2190. test_partOver()*
./tests_chern.sng 2192. test_partUnder()*
./tests_chern.sng 2194. test_SegreA()*
./tests_chern.sng 2196. test_FultonA()*
./tests_chern.sng 2198. test_CSMA()*
./tests_chern.sng 2200. test_EulerAff()*
./tests_chern.sng 2202. test_EulerAffBugFix()*
./tests_chern.sng 2204. test_EulerProj()
./tests_chern.sng 2206. );
./tests_chern.sng 2208. }
./tests_chern.sng 2209> test_full();
1
./tests_chern.sng 2210> $

$Bye.
