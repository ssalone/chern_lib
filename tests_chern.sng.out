                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.3.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   Jun 2022
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \
./tests_chern.sng   1>     LIB "chern.lib";
// ** loaded chern.lib (0.8,Nov_2022)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/lrcalc.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/general.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/ring.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/primdec.lib (4.2.1.1,Jul_2021)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/absfact.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/triang.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/random.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/elim.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/matrix.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/nctools.lib (4.1.2.0,Feb_2019)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/polylib.lib (4.2.0.0,Dec_2020)
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/inout.lib (4.1.2.0,Feb_2019)
./tests_chern.sng   2> LIB "lrcalc.lib";
// ** redefining LRinstall (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRinstall (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoef (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoef (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRskew (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRskew (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoprod (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRcoprod (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRschubmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining LRschubmult (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining string2list (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** redefining string2int (LIB "lrcalc.lib";) ./tests_chern.sng:2
// ** loaded /home/ssalone/Singular4/bin/../share/singular/LIB/lrcalc.lib (4.1.2.0,Feb_2019)
./tests_chern.sng   3> int REZ=1;
./tests_chern.sng   4> proc fail(string s)
./tests_chern.sng   5. {
./tests_chern.sng   6.   return("Failed in "+s);
./tests_chern.sng   8. }
./tests_chern.sng   9> 
./tests_chern.sng  10. proc check(string s)
./tests_chern.sng  11. {
./tests_chern.sng  12.   if(!REZ)
./tests_chern.sng  14.   {
./tests_chern.sng  16.     fail(s);
./tests_chern.sng  18.     REZ=1;
./tests_chern.sng  20.     return(0);
./tests_chern.sng  22.   }
./tests_chern.sng  24.   else
./tests_chern.sng  26.   {
./tests_chern.sng  28.     return(1);
./tests_chern.sng  30.   }
./tests_chern.sng  32. }
./tests_chern.sng  33> 
./tests_chern.sng  34. proc ensure(int b)
./tests_chern.sng  35. {
./tests_chern.sng  36.   if(b)
./tests_chern.sng  38.   {
./tests_chern.sng  40. //    return(1);
./tests_chern.sng  42.   }
./tests_chern.sng  44.   else
./tests_chern.sng  46.   {
./tests_chern.sng  48.     REZ=0;
./tests_chern.sng  50. //    return(0);
./tests_chern.sng  52.   }
./tests_chern.sng  54. }
./tests_chern.sng  55> 
./tests_chern.sng  56. 
./tests_chern.sng  57. proc test_symm()
./tests_chern.sng  58. {
./tests_chern.sng  59.   string s="symm()";
./tests_chern.sng  61.   // elementary symmetric functions in x, y, z:
./tests_chern.sng  63.   ring r = 0, (x, y, z), dp;
./tests_chern.sng  65.   list l=(x, y, z);
./tests_chern.sng  67.   list rez=symm(l);
./tests_chern.sng  69.   ensure(rez[1] == x+y+z);
./tests_chern.sng  71.   ensure(rez[2] ==  xy+xz+yz);
./tests_chern.sng  73.   ensure(rez[3] ==  xyz);
./tests_chern.sng  75. 
./tests_chern.sng  77.   //now let us compute only the first two symmetric polynomials in a(1), ... , a(10)
./tests_chern.sng  79.   ring q= 0,(a(1..10)), dp;
./tests_chern.sng  81.   list l=a(1..10);
./tests_chern.sng  83.   list rez=symm(l, 2);
./tests_chern.sng  85. 
./tests_chern.sng  87.   ensure(rez[1]== a(1)+a(2)+a(3)+a(4)+a(5)+a(6)+a(7)+a(8)+a(9)+a(10));
./tests_chern.sng  89.   ensure(rez[2]== a(1)*a(2)+a(1)*a(3)+a(2)*a(3)+a(1)*a(4)+a(2)*a(4)+a(3)*a(4)+a(1)*a(5)+a(2)*a(5)+a(3)*a(5)+a(4)*a(5)+a(1)*a(6)+a(2)*a(6)+a(3)*a(6)+a(4)*a(6)+a(5)*a(6)+a(1)*a(7)+a(2)*a(7)+a(3)*a(7)+a(4)*a(7)+a(5)*a(7)+a(6)*a(7)+a(1)*a(8)+a(2)*a(8)+a(3)*a(8)+a(4)*a(8)+a(5)*a(8)+a(6)*a(8)+a(7)*a(8)+a(1)*a(9)+a(2)*a(9)+a(3)*a(9)+a(4)*a(9)+a(5)*a(9)+a(6)*a(9)+a(7)*a(9)+a(8)*a(9)+a(1)*a(10)+a(2)*a(10)+a(3)*a(10)+a(4)*a(10)+a(5)*a(10)+a(6)*a(10)+a(7)*a(10)+a(8)*a(10)+a(9)*a(10));
./tests_chern.sng  91.   return(check(s));
./tests_chern.sng  93. 
./tests_chern.sng  95. }
./tests_chern.sng  96> 
./tests_chern.sng  97. proc test_symNsym()
./tests_chern.sng  98. {
./tests_chern.sng  99.   string s="symNsym()";
./tests_chern.sng 101.   ring r=0, (x,y,z, c(1..3)), dp;
./tests_chern.sng 103.   list l=c(1..3);
./tests_chern.sng 105.   // The symmetric part of f = 3x2 + 3y2 + 3z2 + 7xyz + y
./tests_chern.sng 107.   // in terms of the elemenatary symmetric functions c(1), c(2), c(3)
./tests_chern.sng 109.   // and the remainder
./tests_chern.sng 111.   poly f = 3x2 + 3y2 + 3z2 + 7xyz + y;
./tests_chern.sng 113.   list rez= symNsym(f, l);
./tests_chern.sng 115.   ensure(rez[1]== 3*c(1)^2-6*c(2)+7*c(3));
./tests_chern.sng 117.   ensure(rez[2]==  y);
./tests_chern.sng 119.   // Take a symmetrix polynomial in variables x and z
./tests_chern.sng 121.   f=x2+xz+z2;
./tests_chern.sng 123.   // Express it in terms of the elementary the symmetric functions
./tests_chern.sng 125.   rez= symNsym(f, l);
./tests_chern.sng 127.   ensure(rez[1]==c(1)^2-c(2));
./tests_chern.sng 129.   ensure(rez[2]==0);
./tests_chern.sng 131.   return(check(s));
./tests_chern.sng 133. }
./tests_chern.sng 134> 
./tests_chern.sng 135. proc test_symNsymBugFix()
./tests_chern.sng 136. {
./tests_chern.sng 137.   string s="symNsymBugFix()";
./tests_chern.sng 139.   ring R0=0,(z,y,x,s1,s2,s3),lp;
./tests_chern.sng 141.   list ls=s1,s2,s3;
./tests_chern.sng 143.   poly q0=(x^2+2)*(y^2+2)*(z^2+2)-x*(y^2+2)*(z^2+2)-(x^2+2)*y*(z^2+2)-(z^2+2)*(y^2+2)*z;
./tests_chern.sng 145. 
./tests_chern.sng 147.   list result = symNsym(q0,ls);   // this gives the following error
./tests_chern.sng 149.   ensure(result[1] == 2*s1^2*s3-s1*s2^2+s3^2+8);
./tests_chern.sng 151.   ensure(result[2] == z^3*x^2-2*z^3+z^2*y^3+2*z^2*y^2-2*z^2*y+z^2*x^3+2*z^2*x^2-2*z^2*x+4*z^2+z*y^2*x^2-2*z*y^2-4*z+y^3*x^2+y^2*x^3+2*y^2*x^2-2*y^2*x+4*y^2-2*y*x^2-4*y+4*x^2-4*x);
./tests_chern.sng 153.   return(check(s));
./tests_chern.sng 155. }
./tests_chern.sng 156> 
./tests_chern.sng 157. 
./tests_chern.sng 158. proc test_CompleteHomog()
./tests_chern.sng 159. {
./tests_chern.sng 160.   string s= "CompleteHomog()";
./tests_chern.sng 162.   ring r = 0, (x(1..3)), dp;
./tests_chern.sng 164.   list l=x(1..3);
./tests_chern.sng 166.   //Complete homogeneous symmetric polynomials up to degree 3 in variables x(1), x(2), x(3)
./tests_chern.sng 168.   list rez= CompleteHomog(3, l) ;
./tests_chern.sng 170.   ensure(rez[1]==1);
./tests_chern.sng 172.   ensure(rez[2]==x(1));
./tests_chern.sng 174.   ensure(rez[3]== x(1)^2-x(2));
./tests_chern.sng 176.   ensure(rez[4]== x(1)^3-2*x(1)*x(2)+x(3));
./tests_chern.sng 178.   return(check(s));
./tests_chern.sng 180. }
./tests_chern.sng 181> 
./tests_chern.sng 182. proc test_segre()
./tests_chern.sng 183. {
./tests_chern.sng 184.   string s="segre()";
./tests_chern.sng 186.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 188.   list l=c(1..3);
./tests_chern.sng 190.   //Segre classes up to degree 5 in Chern classes c(1), c(2), c(3)
./tests_chern.sng 192.   list rez= segre(l, 5);
./tests_chern.sng 194.   ensure( rez[1] == -c(1));
./tests_chern.sng 196.   ensure( rez[2] == c(1)^2-c(2));
./tests_chern.sng 198.   ensure( rez[3] == -c(1)^3+2*c(1)*c(2)-c(3));
./tests_chern.sng 200.   ensure( rez[4] ==  c(1)^4-3*c(1)^2*c(2)+c(2)^2+2*c(1)*c(3));
./tests_chern.sng 202.   ensure(rez[5] == -c(1)^5+4*c(1)^3*c(2)-3*c(1)*c(2)^2-3*c(1)^2*c(3)+2*c(2)*c(3));
./tests_chern.sng 204.   return(check(s));
./tests_chern.sng 206. 
./tests_chern.sng 208. }
./tests_chern.sng 209> 
./tests_chern.sng 210. 
./tests_chern.sng 211. proc test_chern()
./tests_chern.sng 212. {
./tests_chern.sng 213.   string s="chern()";
./tests_chern.sng 215.   ring r = 0, (s(1..3)), dp;
./tests_chern.sng 217.   list l=s(1..3);
./tests_chern.sng 219.   // Chern classes in Segre classes s(1), s(2), s(3)
./tests_chern.sng 221.   list rez= chern(l);
./tests_chern.sng 223.   ensure(rez[1]==   -s(1));
./tests_chern.sng 225.   ensure(rez[2]==   s(1)^2-s(2));
./tests_chern.sng 227.   ensure(rez[3]==  -s(1)^3+2*s(1)*s(2)-s(3));
./tests_chern.sng 229.   // This procedure is inverse to segre(...). Indeed:
./tests_chern.sng 231.   rez=segre(chern(l), 3) ;
./tests_chern.sng 233.   ensure(rez[1]==  s(1));
./tests_chern.sng 235.   ensure(rez[2]==   s(2));
./tests_chern.sng 237.   ensure(rez[3]==   s(3));
./tests_chern.sng 239.   return(check(s));
./tests_chern.sng 241. 
./tests_chern.sng 243. }
./tests_chern.sng 244> proc test_chNum()
./tests_chern.sng 245. {
./tests_chern.sng 246.   string s="chNum()";
./tests_chern.sng 248.   ring r = 0, (c(1..2)), dp;
./tests_chern.sng 250.   list l=c(1..2);
./tests_chern.sng 252.   // Let c(1) be a variable of degree 1, let c(2) be a variable of degree 2.
./tests_chern.sng 254.   // The monomials in c(1) and c(2) of weighted degree 5 are:
./tests_chern.sng 256.   list rez= chNum( 5, l ) ;
./tests_chern.sng 258.   ensure(rez[1]==   c(1)^5);
./tests_chern.sng 260.   ensure(rez[2]==   c(1)^3*c(2));
./tests_chern.sng 262.   ensure(rez[3]==   c(1)*c(2)^2);
./tests_chern.sng 264.   return(check(s));
./tests_chern.sng 266. }
./tests_chern.sng 267> 
./tests_chern.sng 268. proc test_chNumbers()
./tests_chern.sng 269. {
./tests_chern.sng 270.   string s= "chNumbers()";
./tests_chern.sng 272.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 274.   list l=c(1..3);
./tests_chern.sng 276.   // The Chern numbers of a vector bundle with Chern classes c(1), c(2), c(3)
./tests_chern.sng 278.   // on a 3-fold:
./tests_chern.sng 280.   list rez= chNumbers( 3, l );
./tests_chern.sng 282.   ensure(rez[1] ==  c(1)^3);
./tests_chern.sng 284.   ensure(rez[2]==    c(1)*c(2));
./tests_chern.sng 286.   ensure(rez[3]==   c(3));
./tests_chern.sng 288.   // If the highest Chern class is zero, the Chern numbers are:
./tests_chern.sng 290.   l=c(1..2);
./tests_chern.sng 292.   rez= chNumbers( 3, l );
./tests_chern.sng 294.   ensure(rez[1]==   c(1)^3);
./tests_chern.sng 296.   ensure(rez[2]== c(1)*c(2));
./tests_chern.sng 298.   ensure(rez[3]==   0);
./tests_chern.sng 300.   return(check(s));
./tests_chern.sng 302. }
./tests_chern.sng 303> 
./tests_chern.sng 304. proc test_sum_of_powers()
./tests_chern.sng 305. {
./tests_chern.sng 306.   string s="sum_of_powers()";
./tests_chern.sng 308.   ring r = 0, (x, y, z), dp;
./tests_chern.sng 310.   list l=x, y, z;
./tests_chern.sng 312.   //sum of 7-th powers of x, y, z
./tests_chern.sng 314.   poly rez= sum_of_powers(7, l);
./tests_chern.sng 316.   ensure( rez==x7+y7+z7 );
./tests_chern.sng 318.   return(check(s));
./tests_chern.sng 320. 
./tests_chern.sng 322. }
./tests_chern.sng 323> 
./tests_chern.sng 324. proc test_powSumSym()
./tests_chern.sng 325. {
./tests_chern.sng 326.   string  s= "powSumSym()";
./tests_chern.sng 328. 
./tests_chern.sng 330.   // the expressions of the first 3 sums of powers of 3 variables a(1), a(2), a(3)
./tests_chern.sng 332.   // in terms of the elementary symmetric polynomials c(1), c(2), c(3):
./tests_chern.sng 334.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 336.   list l=(c(1..3));
./tests_chern.sng 338.   list rez=powSumSym(l);
./tests_chern.sng 340.   ensure(rez[1]==  c(1) );
./tests_chern.sng 342.   ensure(rez[2]==  c(1)^2-2*c(2)) ;
./tests_chern.sng 344.   ensure(rez[3]==   c(1)^3-3*c(1)*c(2)+3*c(3));
./tests_chern.sng 346.   
./tests_chern.sng 348.   // The first 5 sums in the same situation
./tests_chern.sng 350.   rez= powSumSym(l, 5);
./tests_chern.sng 352.   ensure(rez[1]==   c(1));
./tests_chern.sng 354.   ensure(rez[2]==  c(1)^2-2*c(2));
./tests_chern.sng 356.   ensure(rez[3]==   c(1)^3-3*c(1)*c(2)+3*c(3));
./tests_chern.sng 358.   ensure(rez[4]==   c(1)^4-4*c(1)^2*c(2)+2*c(2)^2+4*c(1)*c(3) );
./tests_chern.sng 360.   ensure(rez[5]==   c(1)^5-5*c(1)^3*c(2)+5*c(1)*c(2)^2+5*c(1)^2*c(3)-5*c(2)*c(3));
./tests_chern.sng 362.   return(check(s));
./tests_chern.sng 364. }
./tests_chern.sng 365> 
./tests_chern.sng 366. proc test_chAll()
./tests_chern.sng 367. {
./tests_chern.sng 368.   string s="chAll()";
./tests_chern.sng 370.   // Chern character (terms of degree 1, 2, 3)
./tests_chern.sng 372.   // corresponding to the Chern classes c(1), c(2), c(3):
./tests_chern.sng 374.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 376.   list l=(c(1..3));
./tests_chern.sng 378.   list rez= chAll(l);
./tests_chern.sng 380.   ensure(rez[1]==   c(1));
./tests_chern.sng 382.   ensure(rez[2]==   1/2*c(1)^2-c(2));
./tests_chern.sng 384.   ensure(rez[3]==   1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 386.   // terms up to degree 5 in the same situation
./tests_chern.sng 388.   rez=chAll(l, 5);
./tests_chern.sng 390.   ensure(rez[1]==   c(1));
./tests_chern.sng 392.   ensure(rez[2]==   1/2*c(1)^2-c(2));
./tests_chern.sng 394.   ensure(rez[3]==   1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 396.   ensure(rez[4]==   1/24*c(1)^4-1/6*c(1)^2*c(2)+1/12*c(2)^2+1/6*c(1)*c(3));
./tests_chern.sng 398.   ensure(rez[5]==   1/120*c(1)^5-1/24*c(1)^3*c(2)+1/24*c(1)*c(2)^2+1/24*c(1)^2*c(3)-1/24*c(2)*c(3));
./tests_chern.sng 400.   return(check(s));
./tests_chern.sng 402. 
./tests_chern.sng 404. }
./tests_chern.sng 405> 
./tests_chern.sng 406. proc test_chAllInv()
./tests_chern.sng 407. {
./tests_chern.sng 408.   string s="chAllInv()";
./tests_chern.sng 410.   // first 3 Chern classes in terms of the first 3 terms
./tests_chern.sng 412.   // of the Chern character Chern  ch(1), ch(2), ch(3):
./tests_chern.sng 414.   ring r = 0, (ch(1..3)), dp;
./tests_chern.sng 416.   list l=(ch(1..3));
./tests_chern.sng 418.   list rez= chAllInv(l);
./tests_chern.sng 420.   ensure(rez[1]==   ch(1));
./tests_chern.sng 422.   ensure(rez[2]==   1/2*ch(1)^2-ch(2));
./tests_chern.sng 424.   ensure(rez[3]==   1/6*ch(1)^3-ch(1)*ch(2)+2*ch(3));
./tests_chern.sng 426.   // let's see that chAllInv() is inverse to chAll()
./tests_chern.sng 428.   rez=chAll( chAllInv(l) ) ;
./tests_chern.sng 430.   ensure(rez[1]==   ch(1));
./tests_chern.sng 432.   ensure(rez[2]==   ch(2));
./tests_chern.sng 434.   ensure(rez[3]==   ch(3));
./tests_chern.sng 436.   return(check(s));
./tests_chern.sng 438. }
./tests_chern.sng 439> 
./tests_chern.sng 440. proc test_chHE()
./tests_chern.sng 441. {
./tests_chern.sng 442.   string s="chHE()"; 
./tests_chern.sng 444.   ring r = 0, (c(1..3)), dp;
./tests_chern.sng 446.   list l=c(1..3);
./tests_chern.sng 448.   //the third degree term of the Chern character
./tests_chern.sng 450.   poly rez= chHE(l);
./tests_chern.sng 452.   ensure(rez== 1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 454.   return(check(s));
./tests_chern.sng 456. }
./tests_chern.sng 457> 
./tests_chern.sng 458. 
./tests_chern.sng 459. proc test_ChernRootsSum()
./tests_chern.sng 460. {
./tests_chern.sng 461.   string s="ChernRootsSum()";
./tests_chern.sng 463.   ring r = 0, (a(1..3), b(1..2)), dp;
./tests_chern.sng 465.   // assume a(1), a(2), a(3) are the Chern roots of a vector bundle E
./tests_chern.sng 467.   // assume b(1), b(2) are the Chern roots of a vector bundle F
./tests_chern.sng 469.   list l=a(1..3);
./tests_chern.sng 471.   list L=b(1..2);
./tests_chern.sng 473.   // the Chern roots of their direct sum is
./tests_chern.sng 475.   list rez= ChernRootsSum(l, L);
./tests_chern.sng 477.   ensure(rez[1]== a(1));
./tests_chern.sng 479.   ensure(rez[2]== a(2));
./tests_chern.sng 481.   ensure(rez[3]== a(3));
./tests_chern.sng 483.   ensure(rez[4]== b(1));
./tests_chern.sng 485.   ensure(rez[5]== b(2));
./tests_chern.sng 487.   return(check(s));
./tests_chern.sng 489. }
./tests_chern.sng 490> 
./tests_chern.sng 491. proc test_chSum()
./tests_chern.sng 492. {
./tests_chern.sng 493.   string s="chSum()";
./tests_chern.sng 495.   ring r = 0, (c(1..3), C(1..2)), dp;
./tests_chern.sng 497.   // Let E be a vector bundle with Chern classes c(1), c(2), c(3).
./tests_chern.sng 499.   // Let F be a vector bundle with Chern classes C(1), C(2).
./tests_chern.sng 501.   list l=c(1..3);
./tests_chern.sng 503.   list L=C(1..2);
./tests_chern.sng 505.   // Then the Chern classes of their direct sum are
./tests_chern.sng 507.   list rez= chSum(l, L);
./tests_chern.sng 509.   ensure(rez[1]== c(1)+C(1));
./tests_chern.sng 511.   ensure(rez[2]== c(1)*C(1)+c(2)+C(2));
./tests_chern.sng 513.   ensure(rez[3]== c(2)*C(1)+c(1)*C(2)+c(3));
./tests_chern.sng 515.   ensure(rez[4]== c(3)*C(1)+c(2)*C(2));
./tests_chern.sng 517.   ensure(rez[5]== c(3)*C(2));
./tests_chern.sng 519.   return(check(s));
./tests_chern.sng 521. 
./tests_chern.sng 523. }
./tests_chern.sng 524> 
./tests_chern.sng 525. proc test_ChernRootsDual()
./tests_chern.sng 526. {
./tests_chern.sng 527.   string s="ChernRootsDual()";
./tests_chern.sng 529.   ring r = 0, (a(1..3)), dp;
./tests_chern.sng 531.   // assume a(1), a(2), a(3) are the Chern roots of a vector bundle
./tests_chern.sng 533.   list l=a(1..3);
./tests_chern.sng 535.   // the Chern roots of the dual vector bundle
./tests_chern.sng 537.   list rez=ChernRootsDual(l);
./tests_chern.sng 539.   ensure(rez[1]==   -a(1));
./tests_chern.sng 541.   ensure(rez[2]==  -a(2));
./tests_chern.sng 543.   ensure(rez[3]==  -a(3));
./tests_chern.sng 545.   return(check(s));
./tests_chern.sng 547. }
./tests_chern.sng 548> 
./tests_chern.sng 549. proc test_chDual()
./tests_chern.sng 550. {
./tests_chern.sng 551.   string s="chDual()";
./tests_chern.sng 553.   // Chern classes of a vector bundle that is dual to a vector bundle
./tests_chern.sng 555.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 557.   ring r=0, (c(1..3)), dp;
./tests_chern.sng 559.   list l=c(1..3);
./tests_chern.sng 561.   list rez=chDual(l);
./tests_chern.sng 563.   ensure(rez[1]== -c(1));
./tests_chern.sng 565.   ensure(rez[2]==   c(2));
./tests_chern.sng 567.   ensure(rez[3]==  -c(3));
./tests_chern.sng 569. 
./tests_chern.sng 571.   return(check(s));
./tests_chern.sng 573. }
./tests_chern.sng 574> 
./tests_chern.sng 575. proc test_ChernRootsProd()
./tests_chern.sng 576. {
./tests_chern.sng 577.   string s="ChernRootsProd()";
./tests_chern.sng 579.   ring r=0, (a(1..2), b(1..3)), dp;
./tests_chern.sng 581.   list l=a(1..2);
./tests_chern.sng 583.   list L=b(1..3);
./tests_chern.sng 585.   // Chern roots of the tensor product of a vector bundle with Chern roots a(1), a(2)
./tests_chern.sng 587.   // and a vector bundle with Chern roots b(1), b(2), b(3)
./tests_chern.sng 589.   list rez= ChernRootsProd(l, L);
./tests_chern.sng 591.   ensure(rez[1]==   a(1)+b(1));
./tests_chern.sng 593.   ensure(rez[2]==    a(1)+b(2));
./tests_chern.sng 595.   ensure(rez[3]==   a(1)+b(3));
./tests_chern.sng 597.   ensure(rez[4]==   a(2)+b(1));
./tests_chern.sng 599.   ensure(rez[5]==  a(2)+b(2));
./tests_chern.sng 601.   ensure(rez[6]==   a(2)+b(3));
./tests_chern.sng 603.   return(check(s));
./tests_chern.sng 605. }
./tests_chern.sng 606> 
./tests_chern.sng 607. proc test_chProd()
./tests_chern.sng 608. {
./tests_chern.sng 609.   string s="chProd";
./tests_chern.sng 611.   ring H = 0, ( r, R, c(1..3), C(1..2) ), dp;
./tests_chern.sng 613.   list l=c(1..3);
./tests_chern.sng 615.   list L=C(1..2);
./tests_chern.sng 617.   // the Chern classes of the tensor product of a vector bundle E of rank 3
./tests_chern.sng 619.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 621.   // and a vector bundle F of rank 2 with Chern classes C(1) and C(2):
./tests_chern.sng 623.   list rez= chProd(3, l, 2, L) ;
./tests_chern.sng 625.   ensure(rez[1]==   2*c(1)+3*C(1));
./tests_chern.sng 627.   ensure(rez[2]==  c(1)^2+5*c(1)*C(1)+3*C(1)^2+2*c(2)+3*C(2));
./tests_chern.sng 629.   ensure(rez[3]==   2*c(1)^2*C(1)+4*c(1)*C(1)^2+C(1)^3+2*c(1)*c(2)+4*c(2)*C(1)+4*c(1)*C(2)+6*C(1)*C(2)+2*c(3));
./tests_chern.sng 631.   ensure(rez[4]==  c(1)^2*C(1)^2+c(1)*C(1)^3+3*c(1)*c(2)*C(1)+3*c(2)*C(1)^2+2*c(1)^2*C(2)+6*c(1)*C(1)*C(2)+3*C(1)^2*C(2)+c(2)^2+2*c(1)*c(3)+3*c(3)*C(1)+3*C(2)^2);
./tests_chern.sng 633.   ensure(rez[5]==  c(1)*c(2)*C(1)^2+c(2)*C(1)^3+2*c(1)^2*C(1)*C(2)+2*c(1)*C(1)^2*C(2)+c(2)^2*C(1)+2*c(1)*c(3)*C(1)+3*c(3)*C(1)^2+2*c(1)*c(2)*C(2)+2*c(1)*C(2)^2+3*C(1)*C(2)^2+2*c(2)*c(3)-6*c(3)*C(2));
./tests_chern.sng 635.   ensure(rez[6]==  c(1)*c(3)*C(1)^2+c(3)*C(1)^3+c(1)*c(2)*C(1)*C(2)+c(2)*C(1)^2*C(2)+c(1)^2*C(2)^2+c(1)*C(1)*C(2)^2+c(2)*c(3)*C(1)+c(2)^2*C(2)-2*c(1)*c(3)*C(2)-3*c(3)*C(1)*C(2)-2*c(2)*C(2)^2+C(2)^3+c(3)^2);
./tests_chern.sng 637.   // the first two Chern classes of the tensor product
./tests_chern.sng 639.   // of a vector bundle E of rank r with Chern classes c(1) and c(2)
./tests_chern.sng 641.   // and a vector bundle G of rank R with Chern classes C(1) and C(2)
./tests_chern.sng 643.   // this gives the Chern classes of a tensor product on a complex surface
./tests_chern.sng 645.   l=c(1..2);
./tests_chern.sng 647.   L=C(1..2);
./tests_chern.sng 649.   rez= chProd(r, l, R, L, 2 );
./tests_chern.sng 651.   ensure(rez[1]==   R*c(1)+r*C(1));
./tests_chern.sng 653.   ensure(rez[2]==   1/2*R^2*c(1)^2+r*R*c(1)*C(1)+1/2*r^2*C(1)^2-1/2*R*c(1)^2-1/2*r*C(1)^2+R*c(2)-c(1)*C(1)+r*C(2));
./tests_chern.sng 655.   return(check(s));
./tests_chern.sng 657. 
./tests_chern.sng 659. }
./tests_chern.sng 660> 
./tests_chern.sng 661. proc test_chProdE()
./tests_chern.sng 662. {
./tests_chern.sng 663.   string s="chProdE()";
./tests_chern.sng 665.   ring H = 0, ( c(1..3), C(1..2) ), dp;
./tests_chern.sng 667.   list l=c(1..3);
./tests_chern.sng 669.   list L=C(1..2);
./tests_chern.sng 671.   // the Chern classes of the tensor product of a vector bundle E of rank 3
./tests_chern.sng 673.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 675.   // and a vector bundle F of rank 2 with Chern classes C(1) and C(2):
./tests_chern.sng 677.   list rez= chProdE(l,  L);
./tests_chern.sng 679.   ensure(rez[1]==   2*c(1)+3*C(1));
./tests_chern.sng 681.   ensure(rez[2]==   c(1)^2+5*c(1)*C(1)+3*C(1)^2+2*c(2)+3*C(2));
./tests_chern.sng 683.   ensure(rez[3]==   2*c(1)^2*C(1)+4*c(1)*C(1)^2+C(1)^3+2*c(1)*c(2)+4*c(2)*C(1)+4*c(1)*C(2)+6*C(1)*C(2)+2*c(3));
./tests_chern.sng 685.   ensure(rez[4]==   c(1)^2*C(1)^2+c(1)*C(1)^3+3*c(1)*c(2)*C(1)+3*c(2)*C(1)^2+2*c(1)^2*C(2)+6*c(1)*C(1)*C(2)+3*C(1)^2*C(2)+c(2)^2+2*c(1)*c(3)+3*c(3)*C(1)+3*C(2)^2);
./tests_chern.sng 687.   ensure(rez[5]==   c(1)*c(2)*C(1)^2+c(2)*C(1)^3+2*c(1)^2*C(1)*C(2)+2*c(1)*C(1)^2*C(2)+c(2)^2*C(1)+2*c(1)*c(3)*C(1)+3*c(3)*C(1)^2+2*c(1)*c(2)*C(2)+2*c(1)*C(2)^2+3*C(1)*C(2)^2+2*c(2)*c(3)-6*c(3)*C(2));
./tests_chern.sng 689.   ensure(rez[6]==   c(1)*c(3)*C(1)^2+c(3)*C(1)^3+c(1)*c(2)*C(1)*C(2)+c(2)*C(1)^2*C(2)+c(1)^2*C(2)^2+c(1)*C(1)*C(2)^2+c(2)*c(3)*C(1)+c(2)^2*C(2)-2*c(1)*c(3)*C(2)-3*c(3)*C(1)*C(2)-2*c(2)*C(2)^2+C(2)^3+c(3)^2);
./tests_chern.sng 691.   return(check(s));
./tests_chern.sng 693. }
./tests_chern.sng 694> 
./tests_chern.sng 695. proc test_chProdL()
./tests_chern.sng 696. {
./tests_chern.sng 697.   string s="chProdL()";
./tests_chern.sng 699.   // The Chern classes of the tensor product of a vector bundle of rank 3
./tests_chern.sng 701.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 703.   // Chern class C(1)
./tests_chern.sng 705.   ring r = 0, ( c(1..3), C(1)), dp;
./tests_chern.sng 707.   list c=c(1..3);
./tests_chern.sng 709.   list C=C(1);
./tests_chern.sng 711.   list rez= chProdL(3,c,1,C);
./tests_chern.sng 713.   ensure(rez[1]==  c(1)+3*C(1));
./tests_chern.sng 715.   ensure(rez[2]==  2*c(1)*C(1)+3*C(1)^2+c(2));
./tests_chern.sng 717.   ensure(rez[3]==  c(1)*C(1)^2+C(1)^3+c(2)*C(1)+c(3));
./tests_chern.sng 719.   return(check(s));
./tests_chern.sng 721. }
./tests_chern.sng 722> 
./tests_chern.sng 723. 
./tests_chern.sng 724. proc test_chProdLP()
./tests_chern.sng 725. {
./tests_chern.sng 726.   string s="chProdLP()";
./tests_chern.sng 728.   // The total Chern class of the tensor product of a vector bundle of rank 3
./tests_chern.sng 730.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 732.   // Chern class C(1)
./tests_chern.sng 734.   ring r = 0, ( c(1..3), C(1)), ws(1,2,3, 1);
./tests_chern.sng 736.   list c=c(1..3);
./tests_chern.sng 738.   list C=C(1);
./tests_chern.sng 740.   poly rez= chProdLP(3,c,1,C);
./tests_chern.sng 742.   ensure(rez==1+c(1)+3*C(1)+c(2)+2*c(1)*C(1)+3*C(1)^2+c(3)+c(2)*C(1)+c(1)*C(1)^2+C(1)^3);
./tests_chern.sng 744.   return(check(s));
./tests_chern.sng 746. }
./tests_chern.sng 747> 
./tests_chern.sng 748. proc test_chProdM()
./tests_chern.sng 749. {
./tests_chern.sng 750.   string s="chProdM()";
./tests_chern.sng 752.   // The Chern classes of the tensor product of a vector bundle of rank 3
./tests_chern.sng 754.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 756.   // Chern class C(1)
./tests_chern.sng 758.   ring r = 0, ( c(1..3), C(1)), dp;
./tests_chern.sng 760.   list c=c(1..3);
./tests_chern.sng 762.   list C=C(1);
./tests_chern.sng 764.   list rez= chProdM(3,c,1,C);
./tests_chern.sng 766.   ensure(rez[1]==  c(1)+3*C(1));
./tests_chern.sng 768.   ensure(rez[2]==  2*c(1)*C(1)+3*C(1)^2+c(2));
./tests_chern.sng 770.   ensure(rez[3]==  c(1)*C(1)^2+C(1)^3+c(2)*C(1)+c(3));
./tests_chern.sng 772.   return(check(s));
./tests_chern.sng 774. }
./tests_chern.sng 775> 
./tests_chern.sng 776. 
./tests_chern.sng 777. proc test_chProdMP()
./tests_chern.sng 778. {
./tests_chern.sng 779.   string s="chProdMP()";
./tests_chern.sng 781.   // The total Chern class of the tensor product of a vector bundle of rank 3
./tests_chern.sng 783.   // with Chern classes c(1), c(2), c(3) and a vector bundle of rank 1 with
./tests_chern.sng 785.   // Chern class C(1)
./tests_chern.sng 787.   ring r = 0, ( c(1..3), C(1)), ws(1,2,3, 1);
./tests_chern.sng 789.   list c=c(1..3);
./tests_chern.sng 791.   list C=C(1);
./tests_chern.sng 793.   poly rez= chProdMP(3,c,1,C);
./tests_chern.sng 795.   ensure(rez==1+c(1)+3*C(1)+c(2)+2*c(1)*C(1)+3*C(1)^2+c(3)+c(2)*C(1)+c(1)*C(1)^2+C(1)^3);
./tests_chern.sng 797.   return(check(s));
./tests_chern.sng 799. }
./tests_chern.sng 800> 
./tests_chern.sng 801. proc test_ChernRootsHom()
./tests_chern.sng 802. {
./tests_chern.sng 803.   string s="ChernRootsHom()";
./tests_chern.sng 805.   ring r=0, (a(1..2), b(1..3)), dp;
./tests_chern.sng 807.   list l=a(1..2);
./tests_chern.sng 809.   list L=b(1..3);
./tests_chern.sng 811.   // Let E be a vector bundle with Chern roots a(1). a(2),
./tests_chern.sng 813.   // let F be a vector bundle with CHern roots b(1), b(2), b(3).
./tests_chern.sng 815.   // Then the Chern roots of Hom(E, F) are
./tests_chern.sng 817.   list rez=ChernRootsHom(l, L);
./tests_chern.sng 819.   ensure(rez[1]== -a(1)+b(1));
./tests_chern.sng 821.   ensure(rez[2]==   -a(1)+b(2));
./tests_chern.sng 823.   ensure(rez[3]==   -a(1)+b(3));
./tests_chern.sng 825.   ensure(rez[4]==   -a(2)+b(1));
./tests_chern.sng 827.   ensure(rez[5]==   -a(2)+b(2));
./tests_chern.sng 829.   ensure(rez[6]==   -a(2)+b(3));
./tests_chern.sng 831.   return(check(s));
./tests_chern.sng 833. 
./tests_chern.sng 835. }
./tests_chern.sng 836> 
./tests_chern.sng 837. proc test_chHom()
./tests_chern.sng 838. {
./tests_chern.sng 839.   string s="chHom()";
./tests_chern.sng 841.   ring H = 0, ( r, R, c(1..3), C(1..2) ), dp;
./tests_chern.sng 843.   list l=c(1..3);
./tests_chern.sng 845.   list L=C(1..2);
./tests_chern.sng 847.   // the Chern classes of Hom(E, F) for a vector bundle E of rank 3
./tests_chern.sng 849.   // with Chern classes c(1), c(2), c(3)
./tests_chern.sng 851.   // and a vector bundle F of rank 2 with Chern classes C(1) and C(2):
./tests_chern.sng 853.   list rez= chHom(3, l, 2, L);
./tests_chern.sng 855.   ensure(rez[1]==  -2*c(1)+3*C(1));
./tests_chern.sng 857.   ensure(rez[2]==  c(1)^2-5*c(1)*C(1)+3*C(1)^2+2*c(2)+3*C(2));
./tests_chern.sng 859.   ensure(rez[3]==  2*c(1)^2*C(1)-4*c(1)*C(1)^2+C(1)^3-2*c(1)*c(2)+4*c(2)*C(1)-4*c(1)*C(2)+6*C(1)*C(2)-2*c(3));
./tests_chern.sng 861.   ensure(rez[4]==  c(1)^2*C(1)^2-c(1)*C(1)^3-3*c(1)*c(2)*C(1)+3*c(2)*C(1)^2+2*c(1)^2*C(2)-6*c(1)*C(1)*C(2)+3*C(1)^2*C(2)+c(2)^2+2*c(1)*c(3)-3*c(3)*C(1)+3*C(2)^2);
./tests_chern.sng 863.   ensure(rez[5]==  -c(1)*c(2)*C(1)^2+c(2)*C(1)^3+2*c(1)^2*C(1)*C(2)-2*c(1)*C(1)^2*C(2)+c(2)^2*C(1)+2*c(1)*c(3)*C(1)-3*c(3)*C(1)^2-2*c(1)*c(2)*C(2)-2*c(1)*C(2)^2+3*C(1)*C(2)^2-2*c(2)*c(3)+6*c(3)*C(2));
./tests_chern.sng 865.   ensure(rez[6]==  c(1)*c(3)*C(1)^2-c(3)*C(1)^3-c(1)*c(2)*C(1)*C(2)+c(2)*C(1)^2*C(2)+c(1)^2*C(2)^2-c(1)*C(1)*C(2)^2-c(2)*c(3)*C(1)+c(2)^2*C(2)-2*c(1)*c(3)*C(2)+3*c(3)*C(1)*C(2)-2*c(2)*C(2)^2+C(2)^3+c(3)^2);
./tests_chern.sng 867.   
./tests_chern.sng 869.   // the first two Chern classes of Hom(E, F) for a vector bundle E of rank r
./tests_chern.sng 871.   // with Chern classes c(1) and c(2)
./tests_chern.sng 873.   // and a vector bundle G of rank R with Chern classes C(1) and C(2)
./tests_chern.sng 875.   // this gives the Chern classes of a tensor product on a complex surface
./tests_chern.sng 877.   l=c(1..2);
./tests_chern.sng 879.   L=C(1..2);
./tests_chern.sng 881.   rez= chHom(r, l, R, L, 2 ) ;
./tests_chern.sng 883.   ensure(rez[1]==  -R*c(1)+r*C(1));
./tests_chern.sng 885.   ensure(rez[2]==   1/2*R^2*c(1)^2-r*R*c(1)*C(1)+1/2*r^2*C(1)^2-1/2*R*c(1)^2-1/2*r*C(1)^2+R*c(2)+c(1)*C(1)+r*C(2));
./tests_chern.sng 887.   return(check(s));
./tests_chern.sng 889. }
./tests_chern.sng 890> 
./tests_chern.sng 891. proc test_ChernRootsSymm()
./tests_chern.sng 892. {
./tests_chern.sng 893.   string s="ChernRootsSymm()"; 
./tests_chern.sng 895.   ring r=0, (a(1..3)), dp;
./tests_chern.sng 897.   list l=a(1..3);
./tests_chern.sng 899.   // the Chern roots of the second symmetric power of a vector bundle
./tests_chern.sng 901.   // with Chern  roots a(1), a(2), a(3)
./tests_chern.sng 903.   list rez= ChernRootsSymm(2, l) ;
./tests_chern.sng 905.   ensure(rez[1]==   2*a(1));
./tests_chern.sng 907.   ensure(rez[2]==   a(1)+a(2));
./tests_chern.sng 909.   ensure(rez[3]==   a(1)+a(3));
./tests_chern.sng 911.   ensure(rez[4]==   2*a(2));
./tests_chern.sng 913.   ensure(rez[5]==   a(2)+a(3));
./tests_chern.sng 915.   ensure(rez[6]==   2*a(3));
./tests_chern.sng 917.   return(check(s));
./tests_chern.sng 919. }
./tests_chern.sng 920> 
./tests_chern.sng 921. proc test_ChernRootsWedge()
./tests_chern.sng 922. {
./tests_chern.sng 923.   string s="ChernRootsWedge()";
./tests_chern.sng 925.   ring r=0, (a(1..3)), dp;
./tests_chern.sng 927.   list l=a(1..3);
./tests_chern.sng 929.   // the Chern roots of the second exterior power of a vector bundle
./tests_chern.sng 931.   // with Chern  roots a(1), a(2), a(3)
./tests_chern.sng 933.   list rez= ChernRootsWedge(2, l);
./tests_chern.sng 935.   ensure(rez[1]== a(2)+a(3));
./tests_chern.sng 937.   ensure(rez[2]==   a(1)+a(3));
./tests_chern.sng 939.   ensure(rez[3]==   a(1)+a(2));
./tests_chern.sng 941.   return(check(s));
./tests_chern.sng 943. }
./tests_chern.sng 944> 
./tests_chern.sng 945. proc test_chSymm()
./tests_chern.sng 946. {
./tests_chern.sng 947.   string s="chSymm()";
./tests_chern.sng 949.   ring r=0, (c(1..5)), dp;
./tests_chern.sng 951.   list l=c(1..5);
./tests_chern.sng 953.   // the rank and the Chern classes of the second symmetric power of a vector bundle of rank 3
./tests_chern.sng 955.   list rez= chSymm(2, 3, l);
./tests_chern.sng 957.   // the rank should be 6
./tests_chern.sng 959.   ensure(rez[1]==   6);
./tests_chern.sng 961.   rez=rez[2];
./tests_chern.sng 963.   ensure(rez[1]== 4*c(1));
./tests_chern.sng 965.   ensure(rez[2]== 5*c(1)^2+5*c(2));
./tests_chern.sng 967.   ensure(rez[3]== 2*c(1)^3+11*c(1)*c(2)+7*c(3));
./tests_chern.sng 969.   ensure(rez[4]== 6*c(1)^2*c(2)+4*c(2)^2+14*c(1)*c(3));
./tests_chern.sng 971.   ensure(rez[5]== 4*c(1)*c(2)^2+8*c(1)^2*c(3)+4*c(2)*c(3));
./tests_chern.sng 973.   ensure(rez[6]== 8*c(1)*c(2)*c(3)-8*c(3)^2);
./tests_chern.sng 975.   // the rank and the first 3 Chern classes
./tests_chern.sng 977.   // of the second symmetric power of a vector bundle of rank 5
./tests_chern.sng 979.   rez= chSymm(2, 5, l, 1, 2, 3);
./tests_chern.sng 981.   ensure(rez[1]==   15);
./tests_chern.sng 983.   rez=rez[2];
./tests_chern.sng 985.   ensure(rez[1]== 6*c(1));
./tests_chern.sng 987.   ensure(rez[2]== 14*c(1)^2+7*c(2));
./tests_chern.sng 989.   ensure(rez[3]== 16*c(1)^3+31*c(1)*c(2)+9*c(3));
./tests_chern.sng 991.   return(check(s));
./tests_chern.sng 993. }
./tests_chern.sng 994> 
./tests_chern.sng 995. proc test_chSymm2L()
./tests_chern.sng 996. {
./tests_chern.sng 997.   string s="chSymm2L()";
./tests_chern.sng 999.   ring r=0, (c(1..2)), dp;
./tests_chern.sng 1001.   list l=c(1..2);
./tests_chern.sng 1003.   // the Chern classes of the second symmetric power of a vector bundle of rank 2
./tests_chern.sng 1005.   list rez= chSymm2L(2, l);
./tests_chern.sng 1007.   ensure(rez[1]== 3);
./tests_chern.sng 1009.   rez=rez[2];
./tests_chern.sng 1011.   ensure(rez[1]== 3*c(1));
./tests_chern.sng 1013.   ensure(rez[2]== 2*c(1)^2+4*c(2));
./tests_chern.sng 1015.   ensure(rez[3]== 4*c(1)*c(2));
./tests_chern.sng 1017.   return(check(s));
./tests_chern.sng 1019. }
./tests_chern.sng 1020> 
./tests_chern.sng 1021. proc test_chSymm2LP()
./tests_chern.sng 1022. {
./tests_chern.sng 1023.   string s="chSymm2LP()";
./tests_chern.sng 1025.   ring r=0, (c(1..2)), ws(1, 2);
./tests_chern.sng 1027.   list l=c(1..2);
./tests_chern.sng 1029.   // the total Chern class of the second symmetric power of a vector bundle of rank 2
./tests_chern.sng 1031.   poly rez=chSymm2LP(2, l);
./tests_chern.sng 1033.   ensure(rez==1+3*c(1)+2*c(1)^2+4*c(2)+4*c(1)*c(2));
./tests_chern.sng 1035.   return(check(s));
./tests_chern.sng 1037. }
./tests_chern.sng 1038> 
./tests_chern.sng 1039. 
./tests_chern.sng 1040. proc test_chWedge()
./tests_chern.sng 1041. {
./tests_chern.sng 1042.   string s="chWedge()";
./tests_chern.sng 1044.   ring r=0, (c(1..5)), dp;
./tests_chern.sng 1046.   list l=c(1..5);
./tests_chern.sng 1048.   // the rank and the Chern classes of the second exterior power of a vector bundle of rank 3
./tests_chern.sng 1050.   list rez=chWedge(2, 3, l);
./tests_chern.sng 1052.   ensure(rez[1]== 3);
./tests_chern.sng 1054.   rez=rez[2];
./tests_chern.sng 1056.   ensure(rez[1]== 2*c(1));
./tests_chern.sng 1058.   ensure(rez[2]== c(1)^2+c(2));
./tests_chern.sng 1060.   ensure(rez[3]== c(1)*c(2)-c(3));
./tests_chern.sng 1062.   // the rank and the first 3 Chern classes
./tests_chern.sng 1064.   // of the fourth exterior power of a vector bundle of rank 5
./tests_chern.sng 1066.   rez= chWedge(4, 5, l, 1, 2, 3);
./tests_chern.sng 1068.   ensure(rez[1]== 5);
./tests_chern.sng 1070.   rez=rez[2];
./tests_chern.sng 1072.   ensure(rez[1]==4*c(1));
./tests_chern.sng 1074.   ensure(rez[2]==6*c(1)^2+c(2));
./tests_chern.sng 1076.   ensure(rez[3]==  4*c(1)^3+3*c(1)*c(2)-c(3));
./tests_chern.sng 1078.   return(check(s));
./tests_chern.sng 1080. }
./tests_chern.sng 1081> 
./tests_chern.sng 1082. proc test_chWedge2L()
./tests_chern.sng 1083. {
./tests_chern.sng 1084.   string s="chWedge2L()";
./tests_chern.sng 1086.   ring r=0, (c(1..3)), dp;
./tests_chern.sng 1088.   list l=c(1..3);
./tests_chern.sng 1090.   // the Chern classes of the second exterior power of a vector bundle of rank 3
./tests_chern.sng 1092.   list rez=chWedge2L(3, l);
./tests_chern.sng 1094.   ensure(rez[1]== 3);
./tests_chern.sng 1096.   rez=rez[2];
./tests_chern.sng 1098.   ensure(rez[1]== 2*c(1));
./tests_chern.sng 1100.   ensure(rez[2]== c(1)^2+c(2));
./tests_chern.sng 1102.   ensure(rez[3]== c(1)*c(2)-c(3));
./tests_chern.sng 1104.   return(check(s));
./tests_chern.sng 1106. }
./tests_chern.sng 1107> 
./tests_chern.sng 1108. proc test_chWedge2LP()
./tests_chern.sng 1109. {
./tests_chern.sng 1110. string s="chWedge2LP()";
./tests_chern.sng 1112.   ring r=0, (c(1..3)), ws(1,2,3);
./tests_chern.sng 1114.   list l=c(1..3);
./tests_chern.sng 1116.   // the total Chern class of the second exterior power of a vector bundle of rank 3
./tests_chern.sng 1118.   poly rez=chWedge2LP(3, l);
./tests_chern.sng 1120.   ensure(rez==1+2*c(1)+c(1)^2+c(2)+c(1)*c(2)-c(3) );
./tests_chern.sng 1122.   return(check(s));
./tests_chern.sng 1124. }
./tests_chern.sng 1125> 
./tests_chern.sng 1126. proc test_todd()
./tests_chern.sng 1127. {
./tests_chern.sng 1128.   string s="todd()";
./tests_chern.sng 1130.   // the terms of the Todd class up to degree 5
./tests_chern.sng 1132.   // in terms of the Chern classes c(1), c(2), c(3), c(4), c(5)
./tests_chern.sng 1134.   ring r=0, (c(1..5)), dp;
./tests_chern.sng 1136.   list l=c(1..5);
./tests_chern.sng 1138.   list rez= todd( l );
./tests_chern.sng 1140.   ensure(rez[1]== 1/2*c(1));
./tests_chern.sng 1142.   ensure(rez[2]==  1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1144.   ensure(rez[3]== 1/24*c(1)*c(2));
./tests_chern.sng 1146.   ensure(rez[4]==   -1/720*c(1)^4+1/180*c(1)^2*c(2)+1/240*c(2)^2+1/720*c(1)*c(3)-1/720*c(4));
./tests_chern.sng 1148.   ensure(rez[5]==   -1/1440*c(1)^3*c(2)+1/480*c(1)*c(2)^2+1/1440*c(1)^2*c(3)-1/1440*c(1)*c(4));
./tests_chern.sng 1150.   // in the same situation compute only first two terms
./tests_chern.sng 1152.   rez= todd(l, 2);
./tests_chern.sng 1154.   ensure(rez[1]== 1/2*c(1));
./tests_chern.sng 1156.   ensure(rez[2]==  1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1158. 
./tests_chern.sng 1160.   // compute the first 5 terms corresponding to the Chern classes c(1), c(2)
./tests_chern.sng 1162.   l=c(1..2);
./tests_chern.sng 1164.   rez= todd(l, 5) ;
./tests_chern.sng 1166.   ensure(rez[1]==  1/2*c(1));
./tests_chern.sng 1168.   ensure(rez[2]==    1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1170.   ensure(rez[3]==   1/24*c(1)*c(2));
./tests_chern.sng 1172.   ensure(rez[4]==   -1/720*c(1)^4+1/180*c(1)^2*c(2)+1/240*c(2)^2);
./tests_chern.sng 1174.   ensure(rez[5]==   -1/1440*c(1)^3*c(2)+1/480*c(1)*c(2)^2);
./tests_chern.sng 1176.   return(check(s));
./tests_chern.sng 1178. }
./tests_chern.sng 1179> 
./tests_chern.sng 1180. 
./tests_chern.sng 1181. proc test_toddE()
./tests_chern.sng 1182. {
./tests_chern.sng 1183.   string s="toddE()";
./tests_chern.sng 1185.   // first  3 terms of the Todd class in terms of the Chern classes c(1), c(2), c(3)
./tests_chern.sng 1187.   ring r=0, (c(1..3)), dp;
./tests_chern.sng 1189.   list l;
./tests_chern.sng 1191.   //first term
./tests_chern.sng 1193.   l=c(1);
./tests_chern.sng 1195.   poly rez= toddE( l );
./tests_chern.sng 1197.   ensure(rez==1/2*c(1));
./tests_chern.sng 1199.   // second term
./tests_chern.sng 1201.   l=c(1..2);
./tests_chern.sng 1203.   rez= toddE( l );
./tests_chern.sng 1205.   ensure(rez== 1/12*c(1)^2+1/12*c(2));
./tests_chern.sng 1207.   // third term
./tests_chern.sng 1209.   l=c(1..3);
./tests_chern.sng 1211.   rez= toddE( l );
./tests_chern.sng 1213.   ensure(rez==1/24*c(1)*c(2));
./tests_chern.sng 1215.   return(check(s));
./tests_chern.sng 1217. }
./tests_chern.sng 1218> 
./tests_chern.sng 1219. proc test_Bern()
./tests_chern.sng 1220. {
./tests_chern.sng 1221.   string s="Bern()";
./tests_chern.sng 1223.   // first 10 Bernoulli numbers: B(0), ..., B(9)
./tests_chern.sng 1225.   ring r=0,(t), dp;
./tests_chern.sng 1227.   list rez= Bern(9);
./tests_chern.sng 1229.   ensure(rez[1]==1);
./tests_chern.sng 1231.   ensure(rez[2]==1/2);
./tests_chern.sng 1233.   ensure(rez[3]==1/6);
./tests_chern.sng 1235.   ensure(rez[4]==0);
./tests_chern.sng 1237.   ensure(rez[5]==-1/30);
./tests_chern.sng 1239.   ensure(rez[6]==0);
./tests_chern.sng 1241.   ensure(rez[7]==1/42);
./tests_chern.sng 1243.   ensure(rez[8]==0);
./tests_chern.sng 1245.   ensure(rez[9]==-1/30);
./tests_chern.sng 1247.   ensure(rez[10]==0);
./tests_chern.sng 1249.   return(check(s));
./tests_chern.sng 1251. }
./tests_chern.sng 1252> 
./tests_chern.sng 1253. proc test_tdCf()
./tests_chern.sng 1254. {
./tests_chern.sng 1255.   string s="tdCf()"; 
./tests_chern.sng 1257.   // first 5 coefficients
./tests_chern.sng 1259.   ring r=0,(t), dp;
./tests_chern.sng 1261.   list rez= tdCf(4);
./tests_chern.sng 1263.   ensure(rez[1]==1);
./tests_chern.sng 1265.   ensure(rez[2]==1/2);
./tests_chern.sng 1267.   ensure(rez[3]==1/12);
./tests_chern.sng 1269.   ensure(rez[4]==0);
./tests_chern.sng 1271.   ensure(rez[5]==-1/720);
./tests_chern.sng 1273.   return(check(s));
./tests_chern.sng 1275. }
./tests_chern.sng 1276> 
./tests_chern.sng 1277. proc test_tdTerms()
./tests_chern.sng 1278. {
./tests_chern.sng 1279.   string s="tdTerms()";
./tests_chern.sng 1281.   ring r=0, (t), ls;;
./tests_chern.sng 1283.   // the terms of the Todd class of a line bundle with Chern root t up to degree 4
./tests_chern.sng 1285.   list rez=tdTerms(4, t);
./tests_chern.sng 1287.   ensure(rez[1]== 1);
./tests_chern.sng 1289.   ensure(rez[2]==   1/2t);
./tests_chern.sng 1291.   ensure(rez[3]==   1/12t2);
./tests_chern.sng 1293.   ensure(rez[4]==   0);
./tests_chern.sng 1295.   ensure(rez[5]==   -1/720t4);
./tests_chern.sng 1297.   return(check(s));
./tests_chern.sng 1299. }
./tests_chern.sng 1300> 
./tests_chern.sng 1301. proc test_tdFactor()
./tests_chern.sng 1302. {
./tests_chern.sng 1303.   string s="tdFactor()"; 
./tests_chern.sng 1305.   // the Todd class up do degree 4
./tests_chern.sng 1307.   ring r=0,(t), ls;
./tests_chern.sng 1309.   poly rez= tdFactor(4, t);
./tests_chern.sng 1311.   ensure(rez==1+1/2t+1/12t2-1/720t4);
./tests_chern.sng 1313.   return(check(s));
./tests_chern.sng 1315. }
./tests_chern.sng 1316> 
./tests_chern.sng 1317. proc test_cProj()
./tests_chern.sng 1318. {
./tests_chern.sng 1319.   string s="cProj()";
./tests_chern.sng 1321.   ring r=0, (t), dp;
./tests_chern.sng 1323.   // the coefficients of the total Chern class of the complex projective line
./tests_chern.sng 1325.   list rez= cProj(1);
./tests_chern.sng 1327.   ensure(rez[1]==   2);
./tests_chern.sng 1329.   // the coefficients of the total Chern class of the complex projective plane
./tests_chern.sng 1331.   rez= cProj(2) ;
./tests_chern.sng 1333.   ensure(rez[1]==   3);
./tests_chern.sng 1335.   ensure(rez[2]==   3);
./tests_chern.sng 1337.   // the coefficients of the total Chern class of the complex projective space
./tests_chern.sng 1339.   // of dimension three
./tests_chern.sng 1341.   rez= cProj(3) ;
./tests_chern.sng 1343.   ensure(rez[1]==   4);
./tests_chern.sng 1345.   ensure(rez[2]==   6);
./tests_chern.sng 1347.   ensure(rez[3]==   4);
./tests_chern.sng 1349.   return(check(s));
./tests_chern.sng 1351. }
./tests_chern.sng 1352> 
./tests_chern.sng 1353. proc test_chProj()
./tests_chern.sng 1354. {
./tests_chern.sng 1355.   string s="chProj()";
./tests_chern.sng 1357.   ring r=0, (t), dp;
./tests_chern.sng 1359.   // the coefficients of the Chern character of the complex projective line
./tests_chern.sng 1361.   list rez= chProj(1);
./tests_chern.sng 1363.   ensure(rez[1]==1);
./tests_chern.sng 1365.   ensure(rez[2]==2);
./tests_chern.sng 1367.   // the coefficients of the Chern character of the complex projective plane
./tests_chern.sng 1369.   rez= chProj(2) ;
./tests_chern.sng 1371.   ensure(rez[1]==2);
./tests_chern.sng 1373.   ensure(rez[2]==3);
./tests_chern.sng 1375.   ensure(rez[3]==3/2);
./tests_chern.sng 1377.   // the coefficients of the Chern character of the complex 3-dimentional projectice space
./tests_chern.sng 1379.   rez=chProj(3);
./tests_chern.sng 1381.   ensure(rez[1]==3);
./tests_chern.sng 1383.   ensure(rez[2]==4);
./tests_chern.sng 1385.   ensure(rez[3]==2);
./tests_chern.sng 1387.   ensure(rez[4]==2/3);
./tests_chern.sng 1389.   return(check(s));
./tests_chern.sng 1391. }
./tests_chern.sng 1392> 
./tests_chern.sng 1393. proc test_tdProj()
./tests_chern.sng 1394. {
./tests_chern.sng 1395.   string s="tdProj()";
./tests_chern.sng 1397.   ring r=0, (t), dp;
./tests_chern.sng 1399.   // the coefficients of the Todd class of the complex projective line
./tests_chern.sng 1401.   list rez= tdProj(1);
./tests_chern.sng 1403.   ensure(rez[1]==   1);
./tests_chern.sng 1405.   ensure(rez[2]==   1);
./tests_chern.sng 1407.   // the coefficients of the Todd class of the complex projective line
./tests_chern.sng 1409.   rez= tdProj(2);
./tests_chern.sng 1411.   ensure(rez[1]==   1);
./tests_chern.sng 1413.   ensure(rez[2]==   3/2);
./tests_chern.sng 1415.   ensure(rez[3]==   1);
./tests_chern.sng 1417.   // the coefficients of the Todd class of the complex projective line
./tests_chern.sng 1419.   rez= tdProj(3);
./tests_chern.sng 1421.   ensure(rez[1]==  1);
./tests_chern.sng 1423.   ensure(rez[2]==   2);
./tests_chern.sng 1425.   ensure(rez[3]==   11/6);
./tests_chern.sng 1427.   ensure(rez[4]==   1);
./tests_chern.sng 1429.   return(check(s));
./tests_chern.sng 1431. }
./tests_chern.sng 1432> 
./tests_chern.sng 1433. proc test_eulerChProj()
./tests_chern.sng 1434. {
./tests_chern.sng 1435.   string s="eulerChProj()";
./tests_chern.sng 1437.   ring h=0, (r, c(1..3)),  ws(0,1,2,3);
./tests_chern.sng 1439.   list l=c(1..3);
./tests_chern.sng 1441. 
./tests_chern.sng 1443.   // the Euler characteristic of a vector bundle on the projective line
./tests_chern.sng 1445.   poly rez= eulerChProj(1, r, l);
./tests_chern.sng 1447.   ensure(rez==r+c(1));
./tests_chern.sng 1449. 
./tests_chern.sng 1451.   // the Euler characteristic of a vector bundle on the projective plane
./tests_chern.sng 1453.   rez= eulerChProj(2, r, l);
./tests_chern.sng 1455.   ensure(rez==r+3/2*c(1)+1/2*c(1)^2-c(2));
./tests_chern.sng 1457. 
./tests_chern.sng 1459.   // the Euler characteristic of a vector bundle on P_3
./tests_chern.sng 1461.   rez= eulerChProj(3, r, l);
./tests_chern.sng 1463.   ensure(rez==r+11/6*c(1)+c(1)^2-2*c(2)+1/6*c(1)^3-1/2*c(1)*c(2)+1/2*c(3));
./tests_chern.sng 1465. 
./tests_chern.sng 1467.   // assume now that we have a bundle framed at a subplane of P_3
./tests_chern.sng 1469.   // this implies c(1)=c(2)=0
./tests_chern.sng 1471.   l= 0, 0, c(3);
./tests_chern.sng 1473. 
./tests_chern.sng 1475.   // the Euler characteristic is
./tests_chern.sng 1477.   rez= eulerChProj(3, r, l);
./tests_chern.sng 1479.   ensure(rez==r+1/2*c(3));
./tests_chern.sng 1481.   // which implies that c(3) must be even in this case
./tests_chern.sng 1483.   return(check(s));
./tests_chern.sng 1485. }
./tests_chern.sng 1486> 
./tests_chern.sng 1487. proc test_chNumbersProj()
./tests_chern.sng 1488. {
./tests_chern.sng 1489.   string s="chNumbersProj()";
./tests_chern.sng 1491.   ring h=0, (t), dp;
./tests_chern.sng 1493.   // The Chern numbers of the projective plane P_2:
./tests_chern.sng 1495.   list rez= chNumbersProj(2) ;
./tests_chern.sng 1497.   ensure(rez[1]==9);
./tests_chern.sng 1499.   ensure(rez[2]==   3);
./tests_chern.sng 1501. 
./tests_chern.sng 1503.   // The Chern numbers of P_3:
./tests_chern.sng 1505.   rez=chNumbersProj(3);
./tests_chern.sng 1507.   ensure(rez[1]==   64);
./tests_chern.sng 1509.   ensure(rez[2]==   24);
./tests_chern.sng 1511.   ensure(rez[3]==   4);
./tests_chern.sng 1513.   return(check(s));
./tests_chern.sng 1515. }
./tests_chern.sng 1516> 
./tests_chern.sng 1517. proc test_classpoly()
./tests_chern.sng 1518. {
./tests_chern.sng 1519.   string s="classpoly()";
./tests_chern.sng 1521.   ring r=0, (c(1..5), t), ds;
./tests_chern.sng 1523.   list l=c(1..5);
./tests_chern.sng 1525.   // get the polynomial c(1)*t + c(2)*t^2 + ... + c(5)*t^5
./tests_chern.sng 1527.   poly rez= classpoly(l, t);
./tests_chern.sng 1529.   ensure(rez==c(1)*t+c(2)*t^2+c(3)*t^3+c(4)*t^4+c(5)*t^5);
./tests_chern.sng 1531.   return(check(s));
./tests_chern.sng 1533. }
./tests_chern.sng 1534> 
./tests_chern.sng 1535. proc test_chernPoly()
./tests_chern.sng 1536. {
./tests_chern.sng 1537.   string s="chernPoly()"; 
./tests_chern.sng 1539.   ring r=0, (c(1..5), t), ds;
./tests_chern.sng 1541.   list l=c(1..5);
./tests_chern.sng 1543.   // get the Chern polynomial 1 + c(1)*t + c(2)*t^2 + ... + c(5)*t^5
./tests_chern.sng 1545.   poly rez= chernPoly(l, t);
./tests_chern.sng 1547.   ensure(rez==1+c(1)*t+c(2)*t^2+c(3)*t^3+c(4)*t^4+c(5)*t^5);
./tests_chern.sng 1549.   return(check(s));
./tests_chern.sng 1551. }
./tests_chern.sng 1552> 
./tests_chern.sng 1553. proc test_chernCharPoly()
./tests_chern.sng 1554. {
./tests_chern.sng 1555.   string s="chernCharPoly()";
./tests_chern.sng 1557.   ring h=0, (r, ch(1..5), t), ds;
./tests_chern.sng 1559.   list l=ch(1..5);
./tests_chern.sng 1561.   // get the polynomial r + ch(1)*t + ch(2)*t^2 + ... + ch(5)*t^5
./tests_chern.sng 1563.   poly rez= chernCharPoly(r, l, t);
./tests_chern.sng 1565.   ensure(rez==r+ch(1)*t+ch(2)*t^2+ch(3)*t^3+ch(4)*t^4+ch(5)*t^5);
./tests_chern.sng 1567.   return(check(s));
./tests_chern.sng 1569. }
./tests_chern.sng 1570> 
./tests_chern.sng 1571. proc test_toddPoly()
./tests_chern.sng 1572. {
./tests_chern.sng 1573.   string s="toddPoly()";
./tests_chern.sng 1575.   ring r=0, (td(1..5), c(1..5), t), ds;
./tests_chern.sng 1577.   list l=td(1..5);
./tests_chern.sng 1579.   // get the polynomial 1 + td(1)*t + td(2)*t^2 + ... + td(5)*t^5
./tests_chern.sng 1581.   poly rez= toddPoly(l, t);
./tests_chern.sng 1583.   ensure(rez==1+td(1)*t+td(2)*t^2+td(3)*t^3+td(4)*t^4+td(5)*t^5);
./tests_chern.sng 1585.   return(check(s));
./tests_chern.sng 1587. }
./tests_chern.sng 1588> 
./tests_chern.sng 1589. proc test_rHRR()
./tests_chern.sng 1590. {
./tests_chern.sng 1591.   string s="rHRR()";
./tests_chern.sng 1593.   ring r=0, (td(0..3), ch(0..3)), dp;
./tests_chern.sng 1595.   // Let ch(0), ch(1), ch(2), ch(3) be the terms of the Chern character
./tests_chern.sng 1597.   // of a vector bundle E on a 3-fold X.
./tests_chern.sng 1599.   list c = ch(0..3);
./tests_chern.sng 1601.   // Let td(0), td(1), td(2), td(3) be the terms of the Todd class of X.
./tests_chern.sng 1603.   list t = td(0..3);
./tests_chern.sng 1605.   // Then the highest term of the product ch(E).td(X) is:
./tests_chern.sng 1607.   poly rez= rHRR(3, c, t);
./tests_chern.sng 1609.   ensure(rez==td(3)*ch(0)+td(2)*ch(1)+td(1)*ch(2)+td(0)*ch(3));
./tests_chern.sng 1611.   return(check(s));
./tests_chern.sng 1613. }
./tests_chern.sng 1614> 
./tests_chern.sng 1615. proc test_SchurS()
./tests_chern.sng 1616. {
./tests_chern.sng 1617.   string s="SchurS()";
./tests_chern.sng 1619.   // The Schur polynomial corresponding to the partition 1,2,4
./tests_chern.sng 1621.   // and the Segre classes 1, s(1), s(2),..., s(6)
./tests_chern.sng 1623.   ring r=0,(s(1..6)), dp;
./tests_chern.sng 1625.   list I=1,2,4;
./tests_chern.sng 1627.   list S=s(1..6);
./tests_chern.sng 1629.   poly rez=SchurS(I, S);
./tests_chern.sng 1631.   ensure(rez==s(1)*s(2)*s(4)-s(1)^2*s(5)-s(3)*s(4)+s(1)*s(6));
./tests_chern.sng 1633.   // compare this with the Schur polynomial computed using Chern classes
./tests_chern.sng 1635.   list C=chDual(chern(S));
./tests_chern.sng 1637.   rez= SchurCh(I, C) ;
./tests_chern.sng 1639.   ensure(rez==s(1)*s(2)*s(4)-s(1)^2*s(5)-s(3)*s(4)+s(1)*s(6));
./tests_chern.sng 1641.   return(check(s));
./tests_chern.sng 1643. }
./tests_chern.sng 1644> 
./tests_chern.sng 1645. proc test_SchurCh()
./tests_chern.sng 1646. {
./tests_chern.sng 1647.   string s="SchurCh()";
./tests_chern.sng 1649.   // The Schur polynomial corresponding to the partition 1,2,4
./tests_chern.sng 1651.   // and the Chern classes c(1), c(2), c(3)
./tests_chern.sng 1653.   ring r=0,(c(1..3)), dp;
./tests_chern.sng 1655.   list I=1,2,4;
./tests_chern.sng 1657.   list C=c(1..3);
./tests_chern.sng 1659.   poly rez= SchurCh(I, C);
./tests_chern.sng 1661.   ensure(rez==c(1)^2*c(2)*c(3)-c(2)^2*c(3)-c(1)*c(3)^2);
./tests_chern.sng 1663.   // Compare this with the Schur polynomial computed using Segre classes
./tests_chern.sng 1665.   list S=segre( chDual( list(c(1..3)) ), 6 );
./tests_chern.sng 1667.   rez=SchurS(I,S);
./tests_chern.sng 1669.   ensure(rez==  c(1)^2*c(2)*c(3)-c(2)^2*c(3)-c(1)*c(3)^2);
./tests_chern.sng 1671.   return(check(s));
./tests_chern.sng 1673. }
./tests_chern.sng 1674> 
./tests_chern.sng 1675. proc test_part()
./tests_chern.sng 1676. {
./tests_chern.sng 1677.   string s="part()";
./tests_chern.sng 1679.   // partitions into 3 summands of numbers not exceeding 1
./tests_chern.sng 1681.   list rez= part(3, 1);
./tests_chern.sng 1683.   ensure(rez[1][1]==      0);
./tests_chern.sng 1685.   ensure(rez[1][2]==      0);
./tests_chern.sng 1687.   ensure(rez[1][3]==      0);
./tests_chern.sng 1689. 
./tests_chern.sng 1691.   ensure(rez[2][1]==      0);
./tests_chern.sng 1693.   ensure(rez[2][2]==      0);
./tests_chern.sng 1695.   ensure(rez[2][3]==      1);
./tests_chern.sng 1697. 
./tests_chern.sng 1699.   ensure(rez[3][1]==      0);
./tests_chern.sng 1701.   ensure(rez[3][2]==      1);
./tests_chern.sng 1703.   ensure(rez[3][3]==      1);
./tests_chern.sng 1705. 
./tests_chern.sng 1707.   ensure(rez[4][1]==      1);
./tests_chern.sng 1709.   ensure(rez[4][2]==      1);
./tests_chern.sng 1711.   ensure(rez[4][3]==      1);
./tests_chern.sng 1713. 
./tests_chern.sng 1715.   return(check(s));
./tests_chern.sng 1717. }
./tests_chern.sng 1718> 
./tests_chern.sng 1719. 
./tests_chern.sng 1720. 
./tests_chern.sng 1721. proc test_dualPart()
./tests_chern.sng 1722. {
./tests_chern.sng 1723.   string s="dualPart()";
./tests_chern.sng 1725.   // dual partition to (1, 3, 4):
./tests_chern.sng 1727.   list I = 1, 3, 4;
./tests_chern.sng 1729.   list rez= dualPart(I);
./tests_chern.sng 1731.   ensure(rez[1]==   1);
./tests_chern.sng 1733.   ensure(rez[2]==   2);
./tests_chern.sng 1735.   ensure(rez[3]==   2);
./tests_chern.sng 1737.   ensure(rez[4]==   3);
./tests_chern.sng 1739.   return(check(s));
./tests_chern.sng 1741. }
./tests_chern.sng 1742> 
./tests_chern.sng 1743. proc test_PartC()
./tests_chern.sng 1744. {
./tests_chern.sng 1745.   string s="PartC()";
./tests_chern.sng 1747.   // Complement of the partition (1, 3, 4) with respect to 5
./tests_chern.sng 1749.   list I = 1, 3, 4;
./tests_chern.sng 1751.   list rez= PartC(I, 5);
./tests_chern.sng 1753.   ensure(rez[1]==  1);
./tests_chern.sng 1755.   ensure(rez[2]==   2);
./tests_chern.sng 1757.   ensure(rez[3]==   4);
./tests_chern.sng 1759.   return(check(s));
./tests_chern.sng 1761. }
./tests_chern.sng 1762> 
./tests_chern.sng 1763. proc test_partOver()
./tests_chern.sng 1764. {
./tests_chern.sng 1765.   string s="partOver()";
./tests_chern.sng 1767.   // Partitions over the partition (3, 3, 4) with summands not exceeding 4
./tests_chern.sng 1769.   list I = 3, 3, 4;
./tests_chern.sng 1771.   list rez= partOver(4, I);
./tests_chern.sng 1773.   ensure(rez[1][1] == 3);
./tests_chern.sng 1775.   ensure(rez[1][2] == 3);
./tests_chern.sng 1777.   ensure(rez[1][3] == 4);
./tests_chern.sng 1779. 
./tests_chern.sng 1781.   ensure(rez[2][1] == 3);
./tests_chern.sng 1783.   ensure(rez[2][2] == 4);
./tests_chern.sng 1785.   ensure(rez[2][3] == 4);
./tests_chern.sng 1787. 
./tests_chern.sng 1789.   ensure(rez[3][1] == 4);
./tests_chern.sng 1791.   ensure(rez[3][2] == 4);
./tests_chern.sng 1793.   ensure(rez[3][3] == 4);
./tests_chern.sng 1795.   return(check(s));
./tests_chern.sng 1797. }
./tests_chern.sng 1798> 
./tests_chern.sng 1799. 
./tests_chern.sng 1800. proc test_partUnder()
./tests_chern.sng 1801. {
./tests_chern.sng 1802.   string s="partUnder()";
./tests_chern.sng 1804.   // Partitions under the partition (0, 1, 1)
./tests_chern.sng 1806.   list I = 0, 1, 1;
./tests_chern.sng 1808.   list rez= partUnder(I);
./tests_chern.sng 1810.   ensure(rez[1][1] == 0);
./tests_chern.sng 1812.   ensure(rez[1][2] == 0);
./tests_chern.sng 1814.   ensure(rez[1][3] == 0);
./tests_chern.sng 1816. 
./tests_chern.sng 1818.   ensure(rez[2][1] == 0);
./tests_chern.sng 1820.   ensure(rez[2][2] == 0);
./tests_chern.sng 1822.   ensure(rez[2][3] == 1);
./tests_chern.sng 1824. 
./tests_chern.sng 1826.   ensure(rez[3][1] == 0);
./tests_chern.sng 1828.   ensure(rez[3][2] == 1);
./tests_chern.sng 1830.   ensure(rez[3][3] == 1);
./tests_chern.sng 1832.   return(check(s));
./tests_chern.sng 1834. }
./tests_chern.sng 1835> 
./tests_chern.sng 1836. proc test_SegreA()
./tests_chern.sng 1837. {
./tests_chern.sng 1838.   string s="SegreA()";
./tests_chern.sng 1840.   // Consider a 3-dimensional projective space
./tests_chern.sng 1842.   ring r = 0, (x, y, z, w), dp;
./tests_chern.sng 1844.   // Consider 3 non-coplanar lines trough one point and compute the Segre class
./tests_chern.sng 1846.   ideal I=xy, xz, yz;
./tests_chern.sng 1848.   list rez=SegreA(I);
./tests_chern.sng 1850.   ensure(rez[1]==   0);
./tests_chern.sng 1852.   ensure(rez[2]==   0);
./tests_chern.sng 1854.   ensure(rez[3]==   3);
./tests_chern.sng 1856.   ensure(rez[4]==   -10);
./tests_chern.sng 1858.   // Now consider 3 coplanar lines trough one point and its Segre class
./tests_chern.sng 1860.   ideal J=w, x*y*(x+y);
./tests_chern.sng 1862.   rez=SegreA(J);
./tests_chern.sng 1864.   ensure(rez[1]==   0);
./tests_chern.sng 1866.   ensure(rez[2]==   0);
./tests_chern.sng 1868.   ensure(rez[3]==   3);
./tests_chern.sng 1870.   ensure(rez[4]==   -12);
./tests_chern.sng 1872.   return(check(s));
./tests_chern.sng 1874. }
./tests_chern.sng 1875> 
./tests_chern.sng 1876. proc test_FultonA()
./tests_chern.sng 1877. {
./tests_chern.sng 1878.   string s="FultonA()";
./tests_chern.sng 1880.   // Consider a 3-dimensional projective space
./tests_chern.sng 1882.   ring r = 0, (x, y, z, w), dp;
./tests_chern.sng 1884.   // Consider 3 non-coplanar lines trough one point and compute the Fulton class
./tests_chern.sng 1886.   ideal I=xy, xz, yz;
./tests_chern.sng 1888.   list rez=FultonA(I);
./tests_chern.sng 1890.   ensure(rez[1]==   0);
./tests_chern.sng 1892.   ensure(rez[2]==   0);
./tests_chern.sng 1894.   ensure(rez[3]==   3);
./tests_chern.sng 1896.   ensure(rez[4]==   2);
./tests_chern.sng 1898.   // Now consider 3 coplanar lines trough one point and its Fulton class
./tests_chern.sng 1900.   ideal J=w, x*y*(x+y);
./tests_chern.sng 1902.   rez=FultonA(J);
./tests_chern.sng 1904.   ensure(rez[1]==   0);
./tests_chern.sng 1906.   ensure(rez[2]==   0);
./tests_chern.sng 1908.   ensure(rez[3]==   3);
./tests_chern.sng 1910.   ensure(rez[4]==   0);
./tests_chern.sng 1912.   return(check(s));
./tests_chern.sng 1914. }
./tests_chern.sng 1915> 
./tests_chern.sng 1916. 
./tests_chern.sng 1917. proc test_CSMA()
./tests_chern.sng 1918. {
./tests_chern.sng 1919.   string s="CSMA()";
./tests_chern.sng 1921.   // consider the projective plane with homogeneous coordinates x, y, z
./tests_chern.sng 1923.   ring r = 0, (x, y, z), dp;
./tests_chern.sng 1925.   // the Chern-Schwartz-MacPherson class of a smooth cubic:
./tests_chern.sng 1927.   ideal I=x3+y3+z3;
./tests_chern.sng 1929.   list rez=CSMA(I);
./tests_chern.sng 1931.   ensure(rez[1]==   0);
./tests_chern.sng 1933.   ensure(rez[2]==   3);
./tests_chern.sng 1935.   ensure(rez[3]==   0);
./tests_chern.sng 1937.   // the Chern-Schwartz-MacPherson class of singular cubic
./tests_chern.sng 1939.   // that is a union of 3 non-collinear lines:
./tests_chern.sng 1941.   ideal J=x*y*z;
./tests_chern.sng 1943.   rez= CSMA(J);
./tests_chern.sng 1945.   ensure(rez[1]==   0);
./tests_chern.sng 1947.   ensure(rez[2]==   3);
./tests_chern.sng 1949.   ensure(rez[3]==   3);
./tests_chern.sng 1951.   // the Chern-Schwartz-MacPherson class of singular cubic
./tests_chern.sng 1953.   // that is a union of 3 lines passing through one point
./tests_chern.sng 1955.   ideal K=x*y*(x+y);
./tests_chern.sng 1957.   rez=CSMA(K);
./tests_chern.sng 1959.   ensure(rez[1]==   0);
./tests_chern.sng 1961.   ensure(rez[2]==   3);
./tests_chern.sng 1963.   ensure(rez[3]==   4);
./tests_chern.sng 1965.   return(check(s));
./tests_chern.sng 1967. }
./tests_chern.sng 1968> 
./tests_chern.sng 1969. proc test_EulerAff()
./tests_chern.sng 1970. {
./tests_chern.sng 1971.   string s="EulerAff()";
./tests_chern.sng 1973.   ring r = 0, (x, y), dp;
./tests_chern.sng 1975.   // compute the Euler characteristic of the affine ellipric curve y^2=x^3+x+1;
./tests_chern.sng 1977.   ideal I=y2-x3-x-1;
./tests_chern.sng 1979.   ensure(EulerAff(I)==-1);
./tests_chern.sng 1981.   return(check(s));
./tests_chern.sng 1983. }
./tests_chern.sng 1984> 
./tests_chern.sng 1985. proc test_EulerAffBugFix()
./tests_chern.sng 1986. {
./tests_chern.sng 1987.   string s="EulerAffBugFix()";
./tests_chern.sng 1989.   ring r = 0, (a, b, c, d), dp;
./tests_chern.sng 1991.   // compute the Euler characteristic of the affine ellipric curve a3+b3+c3+d3+2*b*d=0;
./tests_chern.sng 1993.   ideal I=a3+b3+c3+d3+2*b*d;
./tests_chern.sng 1995.   ensure(EulerAff(I)==-11);
./tests_chern.sng 1997.   return(check(s));
./tests_chern.sng 1999. }
./tests_chern.sng 2000> 
./tests_chern.sng 2001. 
./tests_chern.sng 2002. proc test_EulerProj()
./tests_chern.sng 2003. {
./tests_chern.sng 2004.   string s="EulerProj()";
./tests_chern.sng 2006.   // consider the projective plane with homogeneous coordinates x, y, z
./tests_chern.sng 2008.   ring r = 0, (x, y, z), dp;
./tests_chern.sng 2010.   // Euler characteristic of a smooth cubic:
./tests_chern.sng 2012.   ideal I=x3+y3+z3;
./tests_chern.sng 2014.   ensure(EulerProj(I)==0);
./tests_chern.sng 2016.   // Euler characteritic of 3 non-collinear lines:
./tests_chern.sng 2018.   ideal J=x*y*z;
./tests_chern.sng 2020.   ensure(EulerProj(J)==3);
./tests_chern.sng 2022.   // Euler characteristic of 3 lines passing through one point
./tests_chern.sng 2024.   ideal K=x*y*(x+y);
./tests_chern.sng 2026.   ensure(EulerProj(K)==4);
./tests_chern.sng 2028.   return(check(s));
./tests_chern.sng 2030. }
./tests_chern.sng 2031> 
./tests_chern.sng 2032. proc test_full()
./tests_chern.sng 2033. {
./tests_chern.sng 2034. return(
./tests_chern.sng 2036. test_symm()*
./tests_chern.sng 2038. test_symNsym()*
./tests_chern.sng 2040. test_symNsymBugFix()*
./tests_chern.sng 2042. test_CompleteHomog()*
./tests_chern.sng 2044. test_segre()*
./tests_chern.sng 2046. test_chern()*
./tests_chern.sng 2048. test_chNum()*
./tests_chern.sng 2050. test_chNumbers()*
./tests_chern.sng 2052. test_sum_of_powers()*
./tests_chern.sng 2054. test_powSumSym()*
./tests_chern.sng 2056. test_chAll()*
./tests_chern.sng 2058. test_chAllInv()*
./tests_chern.sng 2060. test_chHE()*
./tests_chern.sng 2062. test_ChernRootsSum()*
./tests_chern.sng 2064. test_chSum()*
./tests_chern.sng 2066. test_ChernRootsDual()*
./tests_chern.sng 2068. test_chDual()*
./tests_chern.sng 2070. test_ChernRootsProd()*
./tests_chern.sng 2072. test_chProd()*
./tests_chern.sng 2074. test_chProdE()*
./tests_chern.sng 2076. test_chProdL()*
./tests_chern.sng 2078. test_chProdLP()*
./tests_chern.sng 2080. test_chProdM()*
./tests_chern.sng 2082. test_chProdMP()*
./tests_chern.sng 2084. test_ChernRootsHom()*
./tests_chern.sng 2086. test_chHom()*
./tests_chern.sng 2088. test_ChernRootsSymm()*
./tests_chern.sng 2090. test_ChernRootsWedge()*
./tests_chern.sng 2092. test_chSymm()*
./tests_chern.sng 2094. test_chSymm2L()*
./tests_chern.sng 2096. test_chSymm2LP()*
./tests_chern.sng 2098. test_chWedge()*
./tests_chern.sng 2100. test_chWedge2L()*
./tests_chern.sng 2102. test_chWedge2LP()*
./tests_chern.sng 2104. test_todd()*
./tests_chern.sng 2106. test_toddE()*
./tests_chern.sng 2108. test_Bern()*
./tests_chern.sng 2110. test_tdCf()*
./tests_chern.sng 2112. test_tdTerms()*
./tests_chern.sng 2114. test_tdFactor()*
./tests_chern.sng 2116. test_cProj()*
./tests_chern.sng 2118. test_chProj()*
./tests_chern.sng 2120. test_tdProj()*
./tests_chern.sng 2122. test_eulerChProj()*
./tests_chern.sng 2124. test_chNumbersProj()*
./tests_chern.sng 2126. test_classpoly()*
./tests_chern.sng 2128. test_chernPoly()*
./tests_chern.sng 2130. test_chernCharPoly()*
./tests_chern.sng 2132. test_toddPoly()*
./tests_chern.sng 2134. test_rHRR()*
./tests_chern.sng 2136. test_SchurS()*
./tests_chern.sng 2138. test_SchurCh()*
./tests_chern.sng 2140. test_part()*
./tests_chern.sng 2142. test_dualPart()*
./tests_chern.sng 2144. test_PartC()*
./tests_chern.sng 2146. test_partOver()*
./tests_chern.sng 2148. test_partUnder()*
./tests_chern.sng 2150. test_SegreA()*
./tests_chern.sng 2152. test_FultonA()*
./tests_chern.sng 2154. test_CSMA()*
./tests_chern.sng 2156. test_EulerAff()*
./tests_chern.sng 2158. test_EulerAffBugFix()*
./tests_chern.sng 2160. test_EulerProj()
./tests_chern.sng 2162. );
./tests_chern.sng 2164. }
./tests_chern.sng 2165> test_full();
1
./tests_chern.sng 2166> $

$Bye.
